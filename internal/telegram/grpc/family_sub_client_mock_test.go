package grpc

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/inqast/fsmanager/internal/telegram/grpc.FamilySubClient -o ./family_sub_client_mock_test.go -n FamilySubClientMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/inqast/fsmanager/pkg/api"
	"google.golang.org/grpc"
)

// FamilySubClientMock implements FamilySubClient
type FamilySubClientMock struct {
	t minimock.Tester

	funcCreateSubscriber          func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ip1 *api.ID, err error)
	inspectFuncCreateSubscriber   func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption)
	afterCreateSubscriberCounter  uint64
	beforeCreateSubscriberCounter uint64
	CreateSubscriberMock          mFamilySubClientMockCreateSubscriber

	funcCreateSubscription          func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ip1 *api.ID, err error)
	inspectFuncCreateSubscription   func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption)
	afterCreateSubscriptionCounter  uint64
	beforeCreateSubscriptionCounter uint64
	CreateSubscriptionMock          mFamilySubClientMockCreateSubscription

	funcCreateUser          func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ip1 *api.ID, err error)
	inspectFuncCreateUser   func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mFamilySubClientMockCreateUser

	funcDeleteSubscriber          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncDeleteSubscriber   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterDeleteSubscriberCounter  uint64
	beforeDeleteSubscriberCounter uint64
	DeleteSubscriberMock          mFamilySubClientMockDeleteSubscriber

	funcDeleteSubscription          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncDeleteSubscription   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterDeleteSubscriptionCounter  uint64
	beforeDeleteSubscriptionCounter uint64
	DeleteSubscriptionMock          mFamilySubClientMockDeleteSubscription

	funcDeleteUser          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncDeleteUser   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mFamilySubClientMockDeleteUser

	funcGetSubscribersForSubscription          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscribersResponse, err error)
	inspectFuncGetSubscribersForSubscription   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterGetSubscribersForSubscriptionCounter  uint64
	beforeGetSubscribersForSubscriptionCounter uint64
	GetSubscribersForSubscriptionMock          mFamilySubClientMockGetSubscribersForSubscription

	funcGetSubscriptionsForUser          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscriptionsResponse, err error)
	inspectFuncGetSubscriptionsForUser   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterGetSubscriptionsForUserCounter  uint64
	beforeGetSubscriptionsForUserCounter uint64
	GetSubscriptionsForUserMock          mFamilySubClientMockGetSubscriptionsForUser

	funcGetUserByTelegramID          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error)
	inspectFuncGetUserByTelegramID   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterGetUserByTelegramIDCounter  uint64
	beforeGetUserByTelegramIDCounter uint64
	GetUserByTelegramIDMock          mFamilySubClientMockGetUserByTelegramID

	funcGetUsersByIDs          func(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption) (gp2 *api.GetUsersByIDsResponse, err error)
	inspectFuncGetUsersByIDs   func(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption)
	afterGetUsersByIDsCounter  uint64
	beforeGetUsersByIDsCounter uint64
	GetUsersByIDsMock          mFamilySubClientMockGetUsersByIDs

	funcReadSubscriber          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscriber, err error)
	inspectFuncReadSubscriber   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterReadSubscriberCounter  uint64
	beforeReadSubscriberCounter uint64
	ReadSubscriberMock          mFamilySubClientMockReadSubscriber

	funcReadSubscription          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscription, err error)
	inspectFuncReadSubscription   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterReadSubscriptionCounter  uint64
	beforeReadSubscriptionCounter uint64
	ReadSubscriptionMock          mFamilySubClientMockReadSubscription

	funcReadUser          func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error)
	inspectFuncReadUser   func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)
	afterReadUserCounter  uint64
	beforeReadUserCounter uint64
	ReadUserMock          mFamilySubClientMockReadUser

	funcUpdateSubscriber          func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncUpdateSubscriber   func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption)
	afterUpdateSubscriberCounter  uint64
	beforeUpdateSubscriberCounter uint64
	UpdateSubscriberMock          mFamilySubClientMockUpdateSubscriber

	funcUpdateSubscription          func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncUpdateSubscription   func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption)
	afterUpdateSubscriptionCounter  uint64
	beforeUpdateSubscriptionCounter uint64
	UpdateSubscriptionMock          mFamilySubClientMockUpdateSubscription

	funcUpdateUser          func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)
	inspectFuncUpdateUser   func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mFamilySubClientMockUpdateUser
}

// NewFamilySubClientMock returns a mock for FamilySubClient
func NewFamilySubClientMock(t minimock.Tester) *FamilySubClientMock {
	m := &FamilySubClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSubscriberMock = mFamilySubClientMockCreateSubscriber{mock: m}
	m.CreateSubscriberMock.callArgs = []*FamilySubClientMockCreateSubscriberParams{}

	m.CreateSubscriptionMock = mFamilySubClientMockCreateSubscription{mock: m}
	m.CreateSubscriptionMock.callArgs = []*FamilySubClientMockCreateSubscriptionParams{}

	m.CreateUserMock = mFamilySubClientMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*FamilySubClientMockCreateUserParams{}

	m.DeleteSubscriberMock = mFamilySubClientMockDeleteSubscriber{mock: m}
	m.DeleteSubscriberMock.callArgs = []*FamilySubClientMockDeleteSubscriberParams{}

	m.DeleteSubscriptionMock = mFamilySubClientMockDeleteSubscription{mock: m}
	m.DeleteSubscriptionMock.callArgs = []*FamilySubClientMockDeleteSubscriptionParams{}

	m.DeleteUserMock = mFamilySubClientMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*FamilySubClientMockDeleteUserParams{}

	m.GetSubscribersForSubscriptionMock = mFamilySubClientMockGetSubscribersForSubscription{mock: m}
	m.GetSubscribersForSubscriptionMock.callArgs = []*FamilySubClientMockGetSubscribersForSubscriptionParams{}

	m.GetSubscriptionsForUserMock = mFamilySubClientMockGetSubscriptionsForUser{mock: m}
	m.GetSubscriptionsForUserMock.callArgs = []*FamilySubClientMockGetSubscriptionsForUserParams{}

	m.GetUserByTelegramIDMock = mFamilySubClientMockGetUserByTelegramID{mock: m}
	m.GetUserByTelegramIDMock.callArgs = []*FamilySubClientMockGetUserByTelegramIDParams{}

	m.GetUsersByIDsMock = mFamilySubClientMockGetUsersByIDs{mock: m}
	m.GetUsersByIDsMock.callArgs = []*FamilySubClientMockGetUsersByIDsParams{}

	m.ReadSubscriberMock = mFamilySubClientMockReadSubscriber{mock: m}
	m.ReadSubscriberMock.callArgs = []*FamilySubClientMockReadSubscriberParams{}

	m.ReadSubscriptionMock = mFamilySubClientMockReadSubscription{mock: m}
	m.ReadSubscriptionMock.callArgs = []*FamilySubClientMockReadSubscriptionParams{}

	m.ReadUserMock = mFamilySubClientMockReadUser{mock: m}
	m.ReadUserMock.callArgs = []*FamilySubClientMockReadUserParams{}

	m.UpdateSubscriberMock = mFamilySubClientMockUpdateSubscriber{mock: m}
	m.UpdateSubscriberMock.callArgs = []*FamilySubClientMockUpdateSubscriberParams{}

	m.UpdateSubscriptionMock = mFamilySubClientMockUpdateSubscription{mock: m}
	m.UpdateSubscriptionMock.callArgs = []*FamilySubClientMockUpdateSubscriptionParams{}

	m.UpdateUserMock = mFamilySubClientMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*FamilySubClientMockUpdateUserParams{}

	return m
}

type mFamilySubClientMockCreateSubscriber struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockCreateSubscriberExpectation
	expectations       []*FamilySubClientMockCreateSubscriberExpectation

	callArgs []*FamilySubClientMockCreateSubscriberParams
	mutex    sync.RWMutex
}

// FamilySubClientMockCreateSubscriberExpectation specifies expectation struct of the FamilySubClient.CreateSubscriber
type FamilySubClientMockCreateSubscriberExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockCreateSubscriberParams
	results *FamilySubClientMockCreateSubscriberResults
	Counter uint64
}

// FamilySubClientMockCreateSubscriberParams contains parameters of the FamilySubClient.CreateSubscriber
type FamilySubClientMockCreateSubscriberParams struct {
	ctx context.Context
	sp1 *api.Subscriber
	p1  []grpc.CallOption
}

// FamilySubClientMockCreateSubscriberResults contains results of the FamilySubClient.CreateSubscriber
type FamilySubClientMockCreateSubscriberResults struct {
	ip1 *api.ID
	err error
}

// Expect sets up expected params for FamilySubClient.CreateSubscriber
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) Expect(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) *mFamilySubClientMockCreateSubscriber {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("FamilySubClientMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &FamilySubClientMockCreateSubscriberExpectation{}
	}

	mmCreateSubscriber.defaultExpectation.params = &FamilySubClientMockCreateSubscriberParams{ctx, sp1, p1}
	for _, e := range mmCreateSubscriber.expectations {
		if minimock.Equal(e.params, mmCreateSubscriber.defaultExpectation.params) {
			mmCreateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscriber.defaultExpectation.params)
		}
	}

	return mmCreateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.CreateSubscriber
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) Inspect(f func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption)) *mFamilySubClientMockCreateSubscriber {
	if mmCreateSubscriber.mock.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.CreateSubscriber")
	}

	mmCreateSubscriber.mock.inspectFuncCreateSubscriber = f

	return mmCreateSubscriber
}

// Return sets up results that will be returned by FamilySubClient.CreateSubscriber
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) Return(ip1 *api.ID, err error) *FamilySubClientMock {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("FamilySubClientMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &FamilySubClientMockCreateSubscriberExpectation{mock: mmCreateSubscriber.mock}
	}
	mmCreateSubscriber.defaultExpectation.results = &FamilySubClientMockCreateSubscriberResults{ip1, err}
	return mmCreateSubscriber.mock
}

//Set uses given function f to mock the FamilySubClient.CreateSubscriber method
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) Set(f func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ip1 *api.ID, err error)) *FamilySubClientMock {
	if mmCreateSubscriber.defaultExpectation != nil {
		mmCreateSubscriber.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.CreateSubscriber method")
	}

	if len(mmCreateSubscriber.expectations) > 0 {
		mmCreateSubscriber.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.CreateSubscriber method")
	}

	mmCreateSubscriber.mock.funcCreateSubscriber = f
	return mmCreateSubscriber.mock
}

// When sets expectation for the FamilySubClient.CreateSubscriber which will trigger the result defined by the following
// Then helper
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) When(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) *FamilySubClientMockCreateSubscriberExpectation {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("FamilySubClientMock.CreateSubscriber mock is already set by Set")
	}

	expectation := &FamilySubClientMockCreateSubscriberExpectation{
		mock:   mmCreateSubscriber.mock,
		params: &FamilySubClientMockCreateSubscriberParams{ctx, sp1, p1},
	}
	mmCreateSubscriber.expectations = append(mmCreateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.CreateSubscriber return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockCreateSubscriberExpectation) Then(ip1 *api.ID, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockCreateSubscriberResults{ip1, err}
	return e.mock
}

// CreateSubscriber implements FamilySubClient
func (mmCreateSubscriber *FamilySubClientMock) CreateSubscriber(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ip1 *api.ID, err error) {
	mm_atomic.AddUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscriber.afterCreateSubscriberCounter, 1)

	if mmCreateSubscriber.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.inspectFuncCreateSubscriber(ctx, sp1, p1...)
	}

	mm_params := &FamilySubClientMockCreateSubscriberParams{ctx, sp1, p1}

	// Record call args
	mmCreateSubscriber.CreateSubscriberMock.mutex.Lock()
	mmCreateSubscriber.CreateSubscriberMock.callArgs = append(mmCreateSubscriber.CreateSubscriberMock.callArgs, mm_params)
	mmCreateSubscriber.CreateSubscriberMock.mutex.Unlock()

	for _, e := range mmCreateSubscriber.CreateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateSubscriber.CreateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.params
		mm_got := FamilySubClientMockCreateSubscriberParams{ctx, sp1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscriber.t.Errorf("FamilySubClientMock.CreateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscriber.t.Fatal("No results are set for the FamilySubClientMock.CreateSubscriber")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateSubscriber.funcCreateSubscriber != nil {
		return mmCreateSubscriber.funcCreateSubscriber(ctx, sp1, p1...)
	}
	mmCreateSubscriber.t.Fatalf("Unexpected call to FamilySubClientMock.CreateSubscriber. %v %v %v", ctx, sp1, p1)
	return
}

// CreateSubscriberAfterCounter returns a count of finished FamilySubClientMock.CreateSubscriber invocations
func (mmCreateSubscriber *FamilySubClientMock) CreateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.afterCreateSubscriberCounter)
}

// CreateSubscriberBeforeCounter returns a count of FamilySubClientMock.CreateSubscriber invocations
func (mmCreateSubscriber *FamilySubClientMock) CreateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.CreateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscriber *mFamilySubClientMockCreateSubscriber) Calls() []*FamilySubClientMockCreateSubscriberParams {
	mmCreateSubscriber.mutex.RLock()

	argCopy := make([]*FamilySubClientMockCreateSubscriberParams, len(mmCreateSubscriber.callArgs))
	copy(argCopy, mmCreateSubscriber.callArgs)

	mmCreateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriberDone returns true if the count of the CreateSubscriber invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockCreateSubscriberDone() bool {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriberInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockCreateSubscriberInspect() {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		if m.CreateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.CreateSubscriber")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateSubscriber with params: %#v", *m.CreateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.CreateSubscriber")
	}
}

type mFamilySubClientMockCreateSubscription struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockCreateSubscriptionExpectation
	expectations       []*FamilySubClientMockCreateSubscriptionExpectation

	callArgs []*FamilySubClientMockCreateSubscriptionParams
	mutex    sync.RWMutex
}

// FamilySubClientMockCreateSubscriptionExpectation specifies expectation struct of the FamilySubClient.CreateSubscription
type FamilySubClientMockCreateSubscriptionExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockCreateSubscriptionParams
	results *FamilySubClientMockCreateSubscriptionResults
	Counter uint64
}

// FamilySubClientMockCreateSubscriptionParams contains parameters of the FamilySubClient.CreateSubscription
type FamilySubClientMockCreateSubscriptionParams struct {
	ctx context.Context
	sp1 *api.Subscription
	p1  []grpc.CallOption
}

// FamilySubClientMockCreateSubscriptionResults contains results of the FamilySubClient.CreateSubscription
type FamilySubClientMockCreateSubscriptionResults struct {
	ip1 *api.ID
	err error
}

// Expect sets up expected params for FamilySubClient.CreateSubscription
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) Expect(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) *mFamilySubClientMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("FamilySubClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &FamilySubClientMockCreateSubscriptionExpectation{}
	}

	mmCreateSubscription.defaultExpectation.params = &FamilySubClientMockCreateSubscriptionParams{ctx, sp1, p1}
	for _, e := range mmCreateSubscription.expectations {
		if minimock.Equal(e.params, mmCreateSubscription.defaultExpectation.params) {
			mmCreateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscription.defaultExpectation.params)
		}
	}

	return mmCreateSubscription
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.CreateSubscription
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) Inspect(f func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption)) *mFamilySubClientMockCreateSubscription {
	if mmCreateSubscription.mock.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.CreateSubscription")
	}

	mmCreateSubscription.mock.inspectFuncCreateSubscription = f

	return mmCreateSubscription
}

// Return sets up results that will be returned by FamilySubClient.CreateSubscription
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) Return(ip1 *api.ID, err error) *FamilySubClientMock {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("FamilySubClientMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &FamilySubClientMockCreateSubscriptionExpectation{mock: mmCreateSubscription.mock}
	}
	mmCreateSubscription.defaultExpectation.results = &FamilySubClientMockCreateSubscriptionResults{ip1, err}
	return mmCreateSubscription.mock
}

//Set uses given function f to mock the FamilySubClient.CreateSubscription method
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) Set(f func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ip1 *api.ID, err error)) *FamilySubClientMock {
	if mmCreateSubscription.defaultExpectation != nil {
		mmCreateSubscription.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.CreateSubscription method")
	}

	if len(mmCreateSubscription.expectations) > 0 {
		mmCreateSubscription.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.CreateSubscription method")
	}

	mmCreateSubscription.mock.funcCreateSubscription = f
	return mmCreateSubscription.mock
}

// When sets expectation for the FamilySubClient.CreateSubscription which will trigger the result defined by the following
// Then helper
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) When(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) *FamilySubClientMockCreateSubscriptionExpectation {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("FamilySubClientMock.CreateSubscription mock is already set by Set")
	}

	expectation := &FamilySubClientMockCreateSubscriptionExpectation{
		mock:   mmCreateSubscription.mock,
		params: &FamilySubClientMockCreateSubscriptionParams{ctx, sp1, p1},
	}
	mmCreateSubscription.expectations = append(mmCreateSubscription.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.CreateSubscription return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockCreateSubscriptionExpectation) Then(ip1 *api.ID, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockCreateSubscriptionResults{ip1, err}
	return e.mock
}

// CreateSubscription implements FamilySubClient
func (mmCreateSubscription *FamilySubClientMock) CreateSubscription(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ip1 *api.ID, err error) {
	mm_atomic.AddUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscription.afterCreateSubscriptionCounter, 1)

	if mmCreateSubscription.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.inspectFuncCreateSubscription(ctx, sp1, p1...)
	}

	mm_params := &FamilySubClientMockCreateSubscriptionParams{ctx, sp1, p1}

	// Record call args
	mmCreateSubscription.CreateSubscriptionMock.mutex.Lock()
	mmCreateSubscription.CreateSubscriptionMock.callArgs = append(mmCreateSubscription.CreateSubscriptionMock.callArgs, mm_params)
	mmCreateSubscription.CreateSubscriptionMock.mutex.Unlock()

	for _, e := range mmCreateSubscription.CreateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateSubscription.CreateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.params
		mm_got := FamilySubClientMockCreateSubscriptionParams{ctx, sp1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscription.t.Errorf("FamilySubClientMock.CreateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscription.t.Fatal("No results are set for the FamilySubClientMock.CreateSubscription")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateSubscription.funcCreateSubscription != nil {
		return mmCreateSubscription.funcCreateSubscription(ctx, sp1, p1...)
	}
	mmCreateSubscription.t.Fatalf("Unexpected call to FamilySubClientMock.CreateSubscription. %v %v %v", ctx, sp1, p1)
	return
}

// CreateSubscriptionAfterCounter returns a count of finished FamilySubClientMock.CreateSubscription invocations
func (mmCreateSubscription *FamilySubClientMock) CreateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.afterCreateSubscriptionCounter)
}

// CreateSubscriptionBeforeCounter returns a count of FamilySubClientMock.CreateSubscription invocations
func (mmCreateSubscription *FamilySubClientMock) CreateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.CreateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscription *mFamilySubClientMockCreateSubscription) Calls() []*FamilySubClientMockCreateSubscriptionParams {
	mmCreateSubscription.mutex.RLock()

	argCopy := make([]*FamilySubClientMockCreateSubscriptionParams, len(mmCreateSubscription.callArgs))
	copy(argCopy, mmCreateSubscription.callArgs)

	mmCreateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriptionDone returns true if the count of the CreateSubscription invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockCreateSubscriptionDone() bool {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriptionInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockCreateSubscriptionInspect() {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		if m.CreateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.CreateSubscription")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateSubscription with params: %#v", *m.CreateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.CreateSubscription")
	}
}

type mFamilySubClientMockCreateUser struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockCreateUserExpectation
	expectations       []*FamilySubClientMockCreateUserExpectation

	callArgs []*FamilySubClientMockCreateUserParams
	mutex    sync.RWMutex
}

// FamilySubClientMockCreateUserExpectation specifies expectation struct of the FamilySubClient.CreateUser
type FamilySubClientMockCreateUserExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockCreateUserParams
	results *FamilySubClientMockCreateUserResults
	Counter uint64
}

// FamilySubClientMockCreateUserParams contains parameters of the FamilySubClient.CreateUser
type FamilySubClientMockCreateUserParams struct {
	ctx context.Context
	up1 *api.User
	p1  []grpc.CallOption
}

// FamilySubClientMockCreateUserResults contains results of the FamilySubClient.CreateUser
type FamilySubClientMockCreateUserResults struct {
	ip1 *api.ID
	err error
}

// Expect sets up expected params for FamilySubClient.CreateUser
func (mmCreateUser *mFamilySubClientMockCreateUser) Expect(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) *mFamilySubClientMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("FamilySubClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &FamilySubClientMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &FamilySubClientMockCreateUserParams{ctx, up1, p1}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.CreateUser
func (mmCreateUser *mFamilySubClientMockCreateUser) Inspect(f func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption)) *mFamilySubClientMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by FamilySubClient.CreateUser
func (mmCreateUser *mFamilySubClientMockCreateUser) Return(ip1 *api.ID, err error) *FamilySubClientMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("FamilySubClientMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &FamilySubClientMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &FamilySubClientMockCreateUserResults{ip1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the FamilySubClient.CreateUser method
func (mmCreateUser *mFamilySubClientMockCreateUser) Set(f func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ip1 *api.ID, err error)) *FamilySubClientMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the FamilySubClient.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mFamilySubClientMockCreateUser) When(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) *FamilySubClientMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("FamilySubClientMock.CreateUser mock is already set by Set")
	}

	expectation := &FamilySubClientMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &FamilySubClientMockCreateUserParams{ctx, up1, p1},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.CreateUser return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockCreateUserExpectation) Then(ip1 *api.ID, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockCreateUserResults{ip1, err}
	return e.mock
}

// CreateUser implements FamilySubClient
func (mmCreateUser *FamilySubClientMock) CreateUser(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ip1 *api.ID, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, up1, p1...)
	}

	mm_params := &FamilySubClientMockCreateUserParams{ctx, up1, p1}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := FamilySubClientMockCreateUserParams{ctx, up1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("FamilySubClientMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the FamilySubClientMock.CreateUser")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, up1, p1...)
	}
	mmCreateUser.t.Fatalf("Unexpected call to FamilySubClientMock.CreateUser. %v %v %v", ctx, up1, p1)
	return
}

// CreateUserAfterCounter returns a count of finished FamilySubClientMock.CreateUser invocations
func (mmCreateUser *FamilySubClientMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of FamilySubClientMock.CreateUser invocations
func (mmCreateUser *FamilySubClientMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mFamilySubClientMockCreateUser) Calls() []*FamilySubClientMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*FamilySubClientMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.CreateUser")
	}
}

type mFamilySubClientMockDeleteSubscriber struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockDeleteSubscriberExpectation
	expectations       []*FamilySubClientMockDeleteSubscriberExpectation

	callArgs []*FamilySubClientMockDeleteSubscriberParams
	mutex    sync.RWMutex
}

// FamilySubClientMockDeleteSubscriberExpectation specifies expectation struct of the FamilySubClient.DeleteSubscriber
type FamilySubClientMockDeleteSubscriberExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockDeleteSubscriberParams
	results *FamilySubClientMockDeleteSubscriberResults
	Counter uint64
}

// FamilySubClientMockDeleteSubscriberParams contains parameters of the FamilySubClient.DeleteSubscriber
type FamilySubClientMockDeleteSubscriberParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockDeleteSubscriberResults contains results of the FamilySubClient.DeleteSubscriber
type FamilySubClientMockDeleteSubscriberResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.DeleteSubscriber
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("FamilySubClientMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &FamilySubClientMockDeleteSubscriberExpectation{}
	}

	mmDeleteSubscriber.defaultExpectation.params = &FamilySubClientMockDeleteSubscriberParams{ctx, ip1, p1}
	for _, e := range mmDeleteSubscriber.expectations {
		if minimock.Equal(e.params, mmDeleteSubscriber.defaultExpectation.params) {
			mmDeleteSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscriber.defaultExpectation.params)
		}
	}

	return mmDeleteSubscriber
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.DeleteSubscriber
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.DeleteSubscriber")
	}

	mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber = f

	return mmDeleteSubscriber
}

// Return sets up results that will be returned by FamilySubClient.DeleteSubscriber
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("FamilySubClientMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &FamilySubClientMockDeleteSubscriberExpectation{mock: mmDeleteSubscriber.mock}
	}
	mmDeleteSubscriber.defaultExpectation.results = &FamilySubClientMockDeleteSubscriberResults{ep1, err}
	return mmDeleteSubscriber.mock
}

//Set uses given function f to mock the FamilySubClient.DeleteSubscriber method
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmDeleteSubscriber.defaultExpectation != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.DeleteSubscriber method")
	}

	if len(mmDeleteSubscriber.expectations) > 0 {
		mmDeleteSubscriber.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.DeleteSubscriber method")
	}

	mmDeleteSubscriber.mock.funcDeleteSubscriber = f
	return mmDeleteSubscriber.mock
}

// When sets expectation for the FamilySubClient.DeleteSubscriber which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockDeleteSubscriberExpectation {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("FamilySubClientMock.DeleteSubscriber mock is already set by Set")
	}

	expectation := &FamilySubClientMockDeleteSubscriberExpectation{
		mock:   mmDeleteSubscriber.mock,
		params: &FamilySubClientMockDeleteSubscriberParams{ctx, ip1, p1},
	}
	mmDeleteSubscriber.expectations = append(mmDeleteSubscriber.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.DeleteSubscriber return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockDeleteSubscriberExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockDeleteSubscriberResults{ep1, err}
	return e.mock
}

// DeleteSubscriber implements FamilySubClient
func (mmDeleteSubscriber *FamilySubClientMock) DeleteSubscriber(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter, 1)

	if mmDeleteSubscriber.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.inspectFuncDeleteSubscriber(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockDeleteSubscriberParams{ctx, ip1, p1}

	// Record call args
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Lock()
	mmDeleteSubscriber.DeleteSubscriberMock.callArgs = append(mmDeleteSubscriber.DeleteSubscriberMock.callArgs, mm_params)
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Unlock()

	for _, e := range mmDeleteSubscriber.DeleteSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.params
		mm_got := FamilySubClientMockDeleteSubscriberParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscriber.t.Errorf("FamilySubClientMock.DeleteSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscriber.t.Fatal("No results are set for the FamilySubClientMock.DeleteSubscriber")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteSubscriber.funcDeleteSubscriber != nil {
		return mmDeleteSubscriber.funcDeleteSubscriber(ctx, ip1, p1...)
	}
	mmDeleteSubscriber.t.Fatalf("Unexpected call to FamilySubClientMock.DeleteSubscriber. %v %v %v", ctx, ip1, p1)
	return
}

// DeleteSubscriberAfterCounter returns a count of finished FamilySubClientMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *FamilySubClientMock) DeleteSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter)
}

// DeleteSubscriberBeforeCounter returns a count of FamilySubClientMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *FamilySubClientMock) DeleteSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.DeleteSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscriber *mFamilySubClientMockDeleteSubscriber) Calls() []*FamilySubClientMockDeleteSubscriberParams {
	mmDeleteSubscriber.mutex.RLock()

	argCopy := make([]*FamilySubClientMockDeleteSubscriberParams, len(mmDeleteSubscriber.callArgs))
	copy(argCopy, mmDeleteSubscriber.callArgs)

	mmDeleteSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriberDone returns true if the count of the DeleteSubscriber invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockDeleteSubscriberDone() bool {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriberInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockDeleteSubscriberInspect() {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		if m.DeleteSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.DeleteSubscriber")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteSubscriber with params: %#v", *m.DeleteSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.DeleteSubscriber")
	}
}

type mFamilySubClientMockDeleteSubscription struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockDeleteSubscriptionExpectation
	expectations       []*FamilySubClientMockDeleteSubscriptionExpectation

	callArgs []*FamilySubClientMockDeleteSubscriptionParams
	mutex    sync.RWMutex
}

// FamilySubClientMockDeleteSubscriptionExpectation specifies expectation struct of the FamilySubClient.DeleteSubscription
type FamilySubClientMockDeleteSubscriptionExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockDeleteSubscriptionParams
	results *FamilySubClientMockDeleteSubscriptionResults
	Counter uint64
}

// FamilySubClientMockDeleteSubscriptionParams contains parameters of the FamilySubClient.DeleteSubscription
type FamilySubClientMockDeleteSubscriptionParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockDeleteSubscriptionResults contains results of the FamilySubClient.DeleteSubscription
type FamilySubClientMockDeleteSubscriptionResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.DeleteSubscription
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("FamilySubClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &FamilySubClientMockDeleteSubscriptionExpectation{}
	}

	mmDeleteSubscription.defaultExpectation.params = &FamilySubClientMockDeleteSubscriptionParams{ctx, ip1, p1}
	for _, e := range mmDeleteSubscription.expectations {
		if minimock.Equal(e.params, mmDeleteSubscription.defaultExpectation.params) {
			mmDeleteSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscription.defaultExpectation.params)
		}
	}

	return mmDeleteSubscription
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.DeleteSubscription
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockDeleteSubscription {
	if mmDeleteSubscription.mock.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.DeleteSubscription")
	}

	mmDeleteSubscription.mock.inspectFuncDeleteSubscription = f

	return mmDeleteSubscription
}

// Return sets up results that will be returned by FamilySubClient.DeleteSubscription
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("FamilySubClientMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &FamilySubClientMockDeleteSubscriptionExpectation{mock: mmDeleteSubscription.mock}
	}
	mmDeleteSubscription.defaultExpectation.results = &FamilySubClientMockDeleteSubscriptionResults{ep1, err}
	return mmDeleteSubscription.mock
}

//Set uses given function f to mock the FamilySubClient.DeleteSubscription method
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmDeleteSubscription.defaultExpectation != nil {
		mmDeleteSubscription.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.DeleteSubscription method")
	}

	if len(mmDeleteSubscription.expectations) > 0 {
		mmDeleteSubscription.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.DeleteSubscription method")
	}

	mmDeleteSubscription.mock.funcDeleteSubscription = f
	return mmDeleteSubscription.mock
}

// When sets expectation for the FamilySubClient.DeleteSubscription which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockDeleteSubscriptionExpectation {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("FamilySubClientMock.DeleteSubscription mock is already set by Set")
	}

	expectation := &FamilySubClientMockDeleteSubscriptionExpectation{
		mock:   mmDeleteSubscription.mock,
		params: &FamilySubClientMockDeleteSubscriptionParams{ctx, ip1, p1},
	}
	mmDeleteSubscription.expectations = append(mmDeleteSubscription.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.DeleteSubscription return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockDeleteSubscriptionExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockDeleteSubscriptionResults{ep1, err}
	return e.mock
}

// DeleteSubscription implements FamilySubClient
func (mmDeleteSubscription *FamilySubClientMock) DeleteSubscription(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter, 1)

	if mmDeleteSubscription.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.inspectFuncDeleteSubscription(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockDeleteSubscriptionParams{ctx, ip1, p1}

	// Record call args
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Lock()
	mmDeleteSubscription.DeleteSubscriptionMock.callArgs = append(mmDeleteSubscription.DeleteSubscriptionMock.callArgs, mm_params)
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Unlock()

	for _, e := range mmDeleteSubscription.DeleteSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.params
		mm_got := FamilySubClientMockDeleteSubscriptionParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscription.t.Errorf("FamilySubClientMock.DeleteSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscription.t.Fatal("No results are set for the FamilySubClientMock.DeleteSubscription")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteSubscription.funcDeleteSubscription != nil {
		return mmDeleteSubscription.funcDeleteSubscription(ctx, ip1, p1...)
	}
	mmDeleteSubscription.t.Fatalf("Unexpected call to FamilySubClientMock.DeleteSubscription. %v %v %v", ctx, ip1, p1)
	return
}

// DeleteSubscriptionAfterCounter returns a count of finished FamilySubClientMock.DeleteSubscription invocations
func (mmDeleteSubscription *FamilySubClientMock) DeleteSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter)
}

// DeleteSubscriptionBeforeCounter returns a count of FamilySubClientMock.DeleteSubscription invocations
func (mmDeleteSubscription *FamilySubClientMock) DeleteSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.DeleteSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscription *mFamilySubClientMockDeleteSubscription) Calls() []*FamilySubClientMockDeleteSubscriptionParams {
	mmDeleteSubscription.mutex.RLock()

	argCopy := make([]*FamilySubClientMockDeleteSubscriptionParams, len(mmDeleteSubscription.callArgs))
	copy(argCopy, mmDeleteSubscription.callArgs)

	mmDeleteSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriptionDone returns true if the count of the DeleteSubscription invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockDeleteSubscriptionDone() bool {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriptionInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockDeleteSubscriptionInspect() {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		if m.DeleteSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.DeleteSubscription")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteSubscription with params: %#v", *m.DeleteSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.DeleteSubscription")
	}
}

type mFamilySubClientMockDeleteUser struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockDeleteUserExpectation
	expectations       []*FamilySubClientMockDeleteUserExpectation

	callArgs []*FamilySubClientMockDeleteUserParams
	mutex    sync.RWMutex
}

// FamilySubClientMockDeleteUserExpectation specifies expectation struct of the FamilySubClient.DeleteUser
type FamilySubClientMockDeleteUserExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockDeleteUserParams
	results *FamilySubClientMockDeleteUserResults
	Counter uint64
}

// FamilySubClientMockDeleteUserParams contains parameters of the FamilySubClient.DeleteUser
type FamilySubClientMockDeleteUserParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockDeleteUserResults contains results of the FamilySubClient.DeleteUser
type FamilySubClientMockDeleteUserResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.DeleteUser
func (mmDeleteUser *mFamilySubClientMockDeleteUser) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("FamilySubClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &FamilySubClientMockDeleteUserExpectation{}
	}

	mmDeleteUser.defaultExpectation.params = &FamilySubClientMockDeleteUserParams{ctx, ip1, p1}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.DeleteUser
func (mmDeleteUser *mFamilySubClientMockDeleteUser) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by FamilySubClient.DeleteUser
func (mmDeleteUser *mFamilySubClientMockDeleteUser) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("FamilySubClientMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &FamilySubClientMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &FamilySubClientMockDeleteUserResults{ep1, err}
	return mmDeleteUser.mock
}

//Set uses given function f to mock the FamilySubClient.DeleteUser method
func (mmDeleteUser *mFamilySubClientMockDeleteUser) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the FamilySubClient.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mFamilySubClientMockDeleteUser) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("FamilySubClientMock.DeleteUser mock is already set by Set")
	}

	expectation := &FamilySubClientMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &FamilySubClientMockDeleteUserParams{ctx, ip1, p1},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.DeleteUser return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockDeleteUserExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockDeleteUserResults{ep1, err}
	return e.mock
}

// DeleteUser implements FamilySubClient
func (mmDeleteUser *FamilySubClientMock) DeleteUser(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockDeleteUserParams{ctx, ip1, p1}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_got := FamilySubClientMockDeleteUserParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("FamilySubClientMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the FamilySubClientMock.DeleteUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, ip1, p1...)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to FamilySubClientMock.DeleteUser. %v %v %v", ctx, ip1, p1)
	return
}

// DeleteUserAfterCounter returns a count of finished FamilySubClientMock.DeleteUser invocations
func (mmDeleteUser *FamilySubClientMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of FamilySubClientMock.DeleteUser invocations
func (mmDeleteUser *FamilySubClientMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mFamilySubClientMockDeleteUser) Calls() []*FamilySubClientMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*FamilySubClientMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockDeleteUserDone() bool {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.DeleteUser")
	}
}

type mFamilySubClientMockGetSubscribersForSubscription struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockGetSubscribersForSubscriptionExpectation
	expectations       []*FamilySubClientMockGetSubscribersForSubscriptionExpectation

	callArgs []*FamilySubClientMockGetSubscribersForSubscriptionParams
	mutex    sync.RWMutex
}

// FamilySubClientMockGetSubscribersForSubscriptionExpectation specifies expectation struct of the FamilySubClient.GetSubscribersForSubscription
type FamilySubClientMockGetSubscribersForSubscriptionExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockGetSubscribersForSubscriptionParams
	results *FamilySubClientMockGetSubscribersForSubscriptionResults
	Counter uint64
}

// FamilySubClientMockGetSubscribersForSubscriptionParams contains parameters of the FamilySubClient.GetSubscribersForSubscription
type FamilySubClientMockGetSubscribersForSubscriptionParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockGetSubscribersForSubscriptionResults contains results of the FamilySubClient.GetSubscribersForSubscription
type FamilySubClientMockGetSubscribersForSubscriptionResults struct {
	gp1 *api.GetSubscribersResponse
	err error
}

// Expect sets up expected params for FamilySubClient.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockGetSubscribersForSubscription {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("FamilySubClientMock.GetSubscribersForSubscription mock is already set by Set")
	}

	if mmGetSubscribersForSubscription.defaultExpectation == nil {
		mmGetSubscribersForSubscription.defaultExpectation = &FamilySubClientMockGetSubscribersForSubscriptionExpectation{}
	}

	mmGetSubscribersForSubscription.defaultExpectation.params = &FamilySubClientMockGetSubscribersForSubscriptionParams{ctx, ip1, p1}
	for _, e := range mmGetSubscribersForSubscription.expectations {
		if minimock.Equal(e.params, mmGetSubscribersForSubscription.defaultExpectation.params) {
			mmGetSubscribersForSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscribersForSubscription.defaultExpectation.params)
		}
	}

	return mmGetSubscribersForSubscription
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockGetSubscribersForSubscription {
	if mmGetSubscribersForSubscription.mock.inspectFuncGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.GetSubscribersForSubscription")
	}

	mmGetSubscribersForSubscription.mock.inspectFuncGetSubscribersForSubscription = f

	return mmGetSubscribersForSubscription
}

// Return sets up results that will be returned by FamilySubClient.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) Return(gp1 *api.GetSubscribersResponse, err error) *FamilySubClientMock {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("FamilySubClientMock.GetSubscribersForSubscription mock is already set by Set")
	}

	if mmGetSubscribersForSubscription.defaultExpectation == nil {
		mmGetSubscribersForSubscription.defaultExpectation = &FamilySubClientMockGetSubscribersForSubscriptionExpectation{mock: mmGetSubscribersForSubscription.mock}
	}
	mmGetSubscribersForSubscription.defaultExpectation.results = &FamilySubClientMockGetSubscribersForSubscriptionResults{gp1, err}
	return mmGetSubscribersForSubscription.mock
}

//Set uses given function f to mock the FamilySubClient.GetSubscribersForSubscription method
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscribersResponse, err error)) *FamilySubClientMock {
	if mmGetSubscribersForSubscription.defaultExpectation != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.GetSubscribersForSubscription method")
	}

	if len(mmGetSubscribersForSubscription.expectations) > 0 {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.GetSubscribersForSubscription method")
	}

	mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription = f
	return mmGetSubscribersForSubscription.mock
}

// When sets expectation for the FamilySubClient.GetSubscribersForSubscription which will trigger the result defined by the following
// Then helper
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockGetSubscribersForSubscriptionExpectation {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("FamilySubClientMock.GetSubscribersForSubscription mock is already set by Set")
	}

	expectation := &FamilySubClientMockGetSubscribersForSubscriptionExpectation{
		mock:   mmGetSubscribersForSubscription.mock,
		params: &FamilySubClientMockGetSubscribersForSubscriptionParams{ctx, ip1, p1},
	}
	mmGetSubscribersForSubscription.expectations = append(mmGetSubscribersForSubscription.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.GetSubscribersForSubscription return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockGetSubscribersForSubscriptionExpectation) Then(gp1 *api.GetSubscribersResponse, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockGetSubscribersForSubscriptionResults{gp1, err}
	return e.mock
}

// GetSubscribersForSubscription implements FamilySubClient
func (mmGetSubscribersForSubscription *FamilySubClientMock) GetSubscribersForSubscription(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscribersResponse, err error) {
	mm_atomic.AddUint64(&mmGetSubscribersForSubscription.beforeGetSubscribersForSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscribersForSubscription.afterGetSubscribersForSubscriptionCounter, 1)

	if mmGetSubscribersForSubscription.inspectFuncGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.inspectFuncGetSubscribersForSubscription(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockGetSubscribersForSubscriptionParams{ctx, ip1, p1}

	// Record call args
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.mutex.Lock()
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.callArgs = append(mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.callArgs, mm_params)
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.mutex.Unlock()

	for _, e := range mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.params
		mm_got := FamilySubClientMockGetSubscribersForSubscriptionParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscribersForSubscription.t.Errorf("FamilySubClientMock.GetSubscribersForSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscribersForSubscription.t.Fatal("No results are set for the FamilySubClientMock.GetSubscribersForSubscription")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetSubscribersForSubscription.funcGetSubscribersForSubscription != nil {
		return mmGetSubscribersForSubscription.funcGetSubscribersForSubscription(ctx, ip1, p1...)
	}
	mmGetSubscribersForSubscription.t.Fatalf("Unexpected call to FamilySubClientMock.GetSubscribersForSubscription. %v %v %v", ctx, ip1, p1)
	return
}

// GetSubscribersForSubscriptionAfterCounter returns a count of finished FamilySubClientMock.GetSubscribersForSubscription invocations
func (mmGetSubscribersForSubscription *FamilySubClientMock) GetSubscribersForSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribersForSubscription.afterGetSubscribersForSubscriptionCounter)
}

// GetSubscribersForSubscriptionBeforeCounter returns a count of FamilySubClientMock.GetSubscribersForSubscription invocations
func (mmGetSubscribersForSubscription *FamilySubClientMock) GetSubscribersForSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribersForSubscription.beforeGetSubscribersForSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.GetSubscribersForSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscribersForSubscription *mFamilySubClientMockGetSubscribersForSubscription) Calls() []*FamilySubClientMockGetSubscribersForSubscriptionParams {
	mmGetSubscribersForSubscription.mutex.RLock()

	argCopy := make([]*FamilySubClientMockGetSubscribersForSubscriptionParams, len(mmGetSubscribersForSubscription.callArgs))
	copy(argCopy, mmGetSubscribersForSubscription.callArgs)

	mmGetSubscribersForSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscribersForSubscriptionDone returns true if the count of the GetSubscribersForSubscription invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockGetSubscribersForSubscriptionDone() bool {
	for _, e := range m.GetSubscribersForSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersForSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribersForSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscribersForSubscriptionInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockGetSubscribersForSubscriptionInspect() {
	for _, e := range m.GetSubscribersForSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.GetSubscribersForSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersForSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		if m.GetSubscribersForSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.GetSubscribersForSubscription")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.GetSubscribersForSubscription with params: %#v", *m.GetSubscribersForSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribersForSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.GetSubscribersForSubscription")
	}
}

type mFamilySubClientMockGetSubscriptionsForUser struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockGetSubscriptionsForUserExpectation
	expectations       []*FamilySubClientMockGetSubscriptionsForUserExpectation

	callArgs []*FamilySubClientMockGetSubscriptionsForUserParams
	mutex    sync.RWMutex
}

// FamilySubClientMockGetSubscriptionsForUserExpectation specifies expectation struct of the FamilySubClient.GetSubscriptionsForUser
type FamilySubClientMockGetSubscriptionsForUserExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockGetSubscriptionsForUserParams
	results *FamilySubClientMockGetSubscriptionsForUserResults
	Counter uint64
}

// FamilySubClientMockGetSubscriptionsForUserParams contains parameters of the FamilySubClient.GetSubscriptionsForUser
type FamilySubClientMockGetSubscriptionsForUserParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockGetSubscriptionsForUserResults contains results of the FamilySubClient.GetSubscriptionsForUser
type FamilySubClientMockGetSubscriptionsForUserResults struct {
	gp1 *api.GetSubscriptionsResponse
	err error
}

// Expect sets up expected params for FamilySubClient.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockGetSubscriptionsForUser {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("FamilySubClientMock.GetSubscriptionsForUser mock is already set by Set")
	}

	if mmGetSubscriptionsForUser.defaultExpectation == nil {
		mmGetSubscriptionsForUser.defaultExpectation = &FamilySubClientMockGetSubscriptionsForUserExpectation{}
	}

	mmGetSubscriptionsForUser.defaultExpectation.params = &FamilySubClientMockGetSubscriptionsForUserParams{ctx, ip1, p1}
	for _, e := range mmGetSubscriptionsForUser.expectations {
		if minimock.Equal(e.params, mmGetSubscriptionsForUser.defaultExpectation.params) {
			mmGetSubscriptionsForUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscriptionsForUser.defaultExpectation.params)
		}
	}

	return mmGetSubscriptionsForUser
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockGetSubscriptionsForUser {
	if mmGetSubscriptionsForUser.mock.inspectFuncGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.GetSubscriptionsForUser")
	}

	mmGetSubscriptionsForUser.mock.inspectFuncGetSubscriptionsForUser = f

	return mmGetSubscriptionsForUser
}

// Return sets up results that will be returned by FamilySubClient.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) Return(gp1 *api.GetSubscriptionsResponse, err error) *FamilySubClientMock {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("FamilySubClientMock.GetSubscriptionsForUser mock is already set by Set")
	}

	if mmGetSubscriptionsForUser.defaultExpectation == nil {
		mmGetSubscriptionsForUser.defaultExpectation = &FamilySubClientMockGetSubscriptionsForUserExpectation{mock: mmGetSubscriptionsForUser.mock}
	}
	mmGetSubscriptionsForUser.defaultExpectation.results = &FamilySubClientMockGetSubscriptionsForUserResults{gp1, err}
	return mmGetSubscriptionsForUser.mock
}

//Set uses given function f to mock the FamilySubClient.GetSubscriptionsForUser method
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscriptionsResponse, err error)) *FamilySubClientMock {
	if mmGetSubscriptionsForUser.defaultExpectation != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.GetSubscriptionsForUser method")
	}

	if len(mmGetSubscriptionsForUser.expectations) > 0 {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.GetSubscriptionsForUser method")
	}

	mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser = f
	return mmGetSubscriptionsForUser.mock
}

// When sets expectation for the FamilySubClient.GetSubscriptionsForUser which will trigger the result defined by the following
// Then helper
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockGetSubscriptionsForUserExpectation {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("FamilySubClientMock.GetSubscriptionsForUser mock is already set by Set")
	}

	expectation := &FamilySubClientMockGetSubscriptionsForUserExpectation{
		mock:   mmGetSubscriptionsForUser.mock,
		params: &FamilySubClientMockGetSubscriptionsForUserParams{ctx, ip1, p1},
	}
	mmGetSubscriptionsForUser.expectations = append(mmGetSubscriptionsForUser.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.GetSubscriptionsForUser return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockGetSubscriptionsForUserExpectation) Then(gp1 *api.GetSubscriptionsResponse, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockGetSubscriptionsForUserResults{gp1, err}
	return e.mock
}

// GetSubscriptionsForUser implements FamilySubClient
func (mmGetSubscriptionsForUser *FamilySubClientMock) GetSubscriptionsForUser(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (gp1 *api.GetSubscriptionsResponse, err error) {
	mm_atomic.AddUint64(&mmGetSubscriptionsForUser.beforeGetSubscriptionsForUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscriptionsForUser.afterGetSubscriptionsForUserCounter, 1)

	if mmGetSubscriptionsForUser.inspectFuncGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.inspectFuncGetSubscriptionsForUser(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockGetSubscriptionsForUserParams{ctx, ip1, p1}

	// Record call args
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.mutex.Lock()
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.callArgs = append(mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.callArgs, mm_params)
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.mutex.Unlock()

	for _, e := range mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.params
		mm_got := FamilySubClientMockGetSubscriptionsForUserParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscriptionsForUser.t.Errorf("FamilySubClientMock.GetSubscriptionsForUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscriptionsForUser.t.Fatal("No results are set for the FamilySubClientMock.GetSubscriptionsForUser")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetSubscriptionsForUser.funcGetSubscriptionsForUser != nil {
		return mmGetSubscriptionsForUser.funcGetSubscriptionsForUser(ctx, ip1, p1...)
	}
	mmGetSubscriptionsForUser.t.Fatalf("Unexpected call to FamilySubClientMock.GetSubscriptionsForUser. %v %v %v", ctx, ip1, p1)
	return
}

// GetSubscriptionsForUserAfterCounter returns a count of finished FamilySubClientMock.GetSubscriptionsForUser invocations
func (mmGetSubscriptionsForUser *FamilySubClientMock) GetSubscriptionsForUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionsForUser.afterGetSubscriptionsForUserCounter)
}

// GetSubscriptionsForUserBeforeCounter returns a count of FamilySubClientMock.GetSubscriptionsForUser invocations
func (mmGetSubscriptionsForUser *FamilySubClientMock) GetSubscriptionsForUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionsForUser.beforeGetSubscriptionsForUserCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.GetSubscriptionsForUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscriptionsForUser *mFamilySubClientMockGetSubscriptionsForUser) Calls() []*FamilySubClientMockGetSubscriptionsForUserParams {
	mmGetSubscriptionsForUser.mutex.RLock()

	argCopy := make([]*FamilySubClientMockGetSubscriptionsForUserParams, len(mmGetSubscriptionsForUser.callArgs))
	copy(argCopy, mmGetSubscriptionsForUser.callArgs)

	mmGetSubscriptionsForUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionsForUserDone returns true if the count of the GetSubscriptionsForUser invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockGetSubscriptionsForUserDone() bool {
	for _, e := range m.GetSubscriptionsForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionsForUser != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionsForUserInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockGetSubscriptionsForUserInspect() {
	for _, e := range m.GetSubscriptionsForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.GetSubscriptionsForUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		if m.GetSubscriptionsForUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.GetSubscriptionsForUser")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.GetSubscriptionsForUser with params: %#v", *m.GetSubscriptionsForUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionsForUser != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.GetSubscriptionsForUser")
	}
}

type mFamilySubClientMockGetUserByTelegramID struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockGetUserByTelegramIDExpectation
	expectations       []*FamilySubClientMockGetUserByTelegramIDExpectation

	callArgs []*FamilySubClientMockGetUserByTelegramIDParams
	mutex    sync.RWMutex
}

// FamilySubClientMockGetUserByTelegramIDExpectation specifies expectation struct of the FamilySubClient.GetUserByTelegramID
type FamilySubClientMockGetUserByTelegramIDExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockGetUserByTelegramIDParams
	results *FamilySubClientMockGetUserByTelegramIDResults
	Counter uint64
}

// FamilySubClientMockGetUserByTelegramIDParams contains parameters of the FamilySubClient.GetUserByTelegramID
type FamilySubClientMockGetUserByTelegramIDParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockGetUserByTelegramIDResults contains results of the FamilySubClient.GetUserByTelegramID
type FamilySubClientMockGetUserByTelegramIDResults struct {
	up1 *api.User
	err error
}

// Expect sets up expected params for FamilySubClient.GetUserByTelegramID
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockGetUserByTelegramID {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("FamilySubClientMock.GetUserByTelegramID mock is already set by Set")
	}

	if mmGetUserByTelegramID.defaultExpectation == nil {
		mmGetUserByTelegramID.defaultExpectation = &FamilySubClientMockGetUserByTelegramIDExpectation{}
	}

	mmGetUserByTelegramID.defaultExpectation.params = &FamilySubClientMockGetUserByTelegramIDParams{ctx, ip1, p1}
	for _, e := range mmGetUserByTelegramID.expectations {
		if minimock.Equal(e.params, mmGetUserByTelegramID.defaultExpectation.params) {
			mmGetUserByTelegramID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByTelegramID.defaultExpectation.params)
		}
	}

	return mmGetUserByTelegramID
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.GetUserByTelegramID
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockGetUserByTelegramID {
	if mmGetUserByTelegramID.mock.inspectFuncGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.GetUserByTelegramID")
	}

	mmGetUserByTelegramID.mock.inspectFuncGetUserByTelegramID = f

	return mmGetUserByTelegramID
}

// Return sets up results that will be returned by FamilySubClient.GetUserByTelegramID
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) Return(up1 *api.User, err error) *FamilySubClientMock {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("FamilySubClientMock.GetUserByTelegramID mock is already set by Set")
	}

	if mmGetUserByTelegramID.defaultExpectation == nil {
		mmGetUserByTelegramID.defaultExpectation = &FamilySubClientMockGetUserByTelegramIDExpectation{mock: mmGetUserByTelegramID.mock}
	}
	mmGetUserByTelegramID.defaultExpectation.results = &FamilySubClientMockGetUserByTelegramIDResults{up1, err}
	return mmGetUserByTelegramID.mock
}

//Set uses given function f to mock the FamilySubClient.GetUserByTelegramID method
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error)) *FamilySubClientMock {
	if mmGetUserByTelegramID.defaultExpectation != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.GetUserByTelegramID method")
	}

	if len(mmGetUserByTelegramID.expectations) > 0 {
		mmGetUserByTelegramID.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.GetUserByTelegramID method")
	}

	mmGetUserByTelegramID.mock.funcGetUserByTelegramID = f
	return mmGetUserByTelegramID.mock
}

// When sets expectation for the FamilySubClient.GetUserByTelegramID which will trigger the result defined by the following
// Then helper
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockGetUserByTelegramIDExpectation {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("FamilySubClientMock.GetUserByTelegramID mock is already set by Set")
	}

	expectation := &FamilySubClientMockGetUserByTelegramIDExpectation{
		mock:   mmGetUserByTelegramID.mock,
		params: &FamilySubClientMockGetUserByTelegramIDParams{ctx, ip1, p1},
	}
	mmGetUserByTelegramID.expectations = append(mmGetUserByTelegramID.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.GetUserByTelegramID return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockGetUserByTelegramIDExpectation) Then(up1 *api.User, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockGetUserByTelegramIDResults{up1, err}
	return e.mock
}

// GetUserByTelegramID implements FamilySubClient
func (mmGetUserByTelegramID *FamilySubClientMock) GetUserByTelegramID(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByTelegramID.beforeGetUserByTelegramIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByTelegramID.afterGetUserByTelegramIDCounter, 1)

	if mmGetUserByTelegramID.inspectFuncGetUserByTelegramID != nil {
		mmGetUserByTelegramID.inspectFuncGetUserByTelegramID(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockGetUserByTelegramIDParams{ctx, ip1, p1}

	// Record call args
	mmGetUserByTelegramID.GetUserByTelegramIDMock.mutex.Lock()
	mmGetUserByTelegramID.GetUserByTelegramIDMock.callArgs = append(mmGetUserByTelegramID.GetUserByTelegramIDMock.callArgs, mm_params)
	mmGetUserByTelegramID.GetUserByTelegramIDMock.mutex.Unlock()

	for _, e := range mmGetUserByTelegramID.GetUserByTelegramIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.params
		mm_got := FamilySubClientMockGetUserByTelegramIDParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByTelegramID.t.Errorf("FamilySubClientMock.GetUserByTelegramID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByTelegramID.t.Fatal("No results are set for the FamilySubClientMock.GetUserByTelegramID")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByTelegramID.funcGetUserByTelegramID != nil {
		return mmGetUserByTelegramID.funcGetUserByTelegramID(ctx, ip1, p1...)
	}
	mmGetUserByTelegramID.t.Fatalf("Unexpected call to FamilySubClientMock.GetUserByTelegramID. %v %v %v", ctx, ip1, p1)
	return
}

// GetUserByTelegramIDAfterCounter returns a count of finished FamilySubClientMock.GetUserByTelegramID invocations
func (mmGetUserByTelegramID *FamilySubClientMock) GetUserByTelegramIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByTelegramID.afterGetUserByTelegramIDCounter)
}

// GetUserByTelegramIDBeforeCounter returns a count of FamilySubClientMock.GetUserByTelegramID invocations
func (mmGetUserByTelegramID *FamilySubClientMock) GetUserByTelegramIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByTelegramID.beforeGetUserByTelegramIDCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.GetUserByTelegramID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByTelegramID *mFamilySubClientMockGetUserByTelegramID) Calls() []*FamilySubClientMockGetUserByTelegramIDParams {
	mmGetUserByTelegramID.mutex.RLock()

	argCopy := make([]*FamilySubClientMockGetUserByTelegramIDParams, len(mmGetUserByTelegramID.callArgs))
	copy(argCopy, mmGetUserByTelegramID.callArgs)

	mmGetUserByTelegramID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByTelegramIDDone returns true if the count of the GetUserByTelegramID invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockGetUserByTelegramIDDone() bool {
	for _, e := range m.GetUserByTelegramIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByTelegramIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByTelegramID != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByTelegramIDInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockGetUserByTelegramIDInspect() {
	for _, e := range m.GetUserByTelegramIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.GetUserByTelegramID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByTelegramIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		if m.GetUserByTelegramIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.GetUserByTelegramID")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.GetUserByTelegramID with params: %#v", *m.GetUserByTelegramIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByTelegramID != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.GetUserByTelegramID")
	}
}

type mFamilySubClientMockGetUsersByIDs struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockGetUsersByIDsExpectation
	expectations       []*FamilySubClientMockGetUsersByIDsExpectation

	callArgs []*FamilySubClientMockGetUsersByIDsParams
	mutex    sync.RWMutex
}

// FamilySubClientMockGetUsersByIDsExpectation specifies expectation struct of the FamilySubClient.GetUsersByIDs
type FamilySubClientMockGetUsersByIDsExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockGetUsersByIDsParams
	results *FamilySubClientMockGetUsersByIDsResults
	Counter uint64
}

// FamilySubClientMockGetUsersByIDsParams contains parameters of the FamilySubClient.GetUsersByIDs
type FamilySubClientMockGetUsersByIDsParams struct {
	ctx context.Context
	gp1 *api.GetUsersByIDsRequest
	p1  []grpc.CallOption
}

// FamilySubClientMockGetUsersByIDsResults contains results of the FamilySubClient.GetUsersByIDs
type FamilySubClientMockGetUsersByIDsResults struct {
	gp2 *api.GetUsersByIDsResponse
	err error
}

// Expect sets up expected params for FamilySubClient.GetUsersByIDs
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) Expect(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption) *mFamilySubClientMockGetUsersByIDs {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("FamilySubClientMock.GetUsersByIDs mock is already set by Set")
	}

	if mmGetUsersByIDs.defaultExpectation == nil {
		mmGetUsersByIDs.defaultExpectation = &FamilySubClientMockGetUsersByIDsExpectation{}
	}

	mmGetUsersByIDs.defaultExpectation.params = &FamilySubClientMockGetUsersByIDsParams{ctx, gp1, p1}
	for _, e := range mmGetUsersByIDs.expectations {
		if minimock.Equal(e.params, mmGetUsersByIDs.defaultExpectation.params) {
			mmGetUsersByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUsersByIDs.defaultExpectation.params)
		}
	}

	return mmGetUsersByIDs
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.GetUsersByIDs
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) Inspect(f func(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption)) *mFamilySubClientMockGetUsersByIDs {
	if mmGetUsersByIDs.mock.inspectFuncGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.GetUsersByIDs")
	}

	mmGetUsersByIDs.mock.inspectFuncGetUsersByIDs = f

	return mmGetUsersByIDs
}

// Return sets up results that will be returned by FamilySubClient.GetUsersByIDs
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) Return(gp2 *api.GetUsersByIDsResponse, err error) *FamilySubClientMock {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("FamilySubClientMock.GetUsersByIDs mock is already set by Set")
	}

	if mmGetUsersByIDs.defaultExpectation == nil {
		mmGetUsersByIDs.defaultExpectation = &FamilySubClientMockGetUsersByIDsExpectation{mock: mmGetUsersByIDs.mock}
	}
	mmGetUsersByIDs.defaultExpectation.results = &FamilySubClientMockGetUsersByIDsResults{gp2, err}
	return mmGetUsersByIDs.mock
}

//Set uses given function f to mock the FamilySubClient.GetUsersByIDs method
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) Set(f func(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption) (gp2 *api.GetUsersByIDsResponse, err error)) *FamilySubClientMock {
	if mmGetUsersByIDs.defaultExpectation != nil {
		mmGetUsersByIDs.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.GetUsersByIDs method")
	}

	if len(mmGetUsersByIDs.expectations) > 0 {
		mmGetUsersByIDs.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.GetUsersByIDs method")
	}

	mmGetUsersByIDs.mock.funcGetUsersByIDs = f
	return mmGetUsersByIDs.mock
}

// When sets expectation for the FamilySubClient.GetUsersByIDs which will trigger the result defined by the following
// Then helper
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) When(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption) *FamilySubClientMockGetUsersByIDsExpectation {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("FamilySubClientMock.GetUsersByIDs mock is already set by Set")
	}

	expectation := &FamilySubClientMockGetUsersByIDsExpectation{
		mock:   mmGetUsersByIDs.mock,
		params: &FamilySubClientMockGetUsersByIDsParams{ctx, gp1, p1},
	}
	mmGetUsersByIDs.expectations = append(mmGetUsersByIDs.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.GetUsersByIDs return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockGetUsersByIDsExpectation) Then(gp2 *api.GetUsersByIDsResponse, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockGetUsersByIDsResults{gp2, err}
	return e.mock
}

// GetUsersByIDs implements FamilySubClient
func (mmGetUsersByIDs *FamilySubClientMock) GetUsersByIDs(ctx context.Context, gp1 *api.GetUsersByIDsRequest, p1 ...grpc.CallOption) (gp2 *api.GetUsersByIDsResponse, err error) {
	mm_atomic.AddUint64(&mmGetUsersByIDs.beforeGetUsersByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUsersByIDs.afterGetUsersByIDsCounter, 1)

	if mmGetUsersByIDs.inspectFuncGetUsersByIDs != nil {
		mmGetUsersByIDs.inspectFuncGetUsersByIDs(ctx, gp1, p1...)
	}

	mm_params := &FamilySubClientMockGetUsersByIDsParams{ctx, gp1, p1}

	// Record call args
	mmGetUsersByIDs.GetUsersByIDsMock.mutex.Lock()
	mmGetUsersByIDs.GetUsersByIDsMock.callArgs = append(mmGetUsersByIDs.GetUsersByIDsMock.callArgs, mm_params)
	mmGetUsersByIDs.GetUsersByIDsMock.mutex.Unlock()

	for _, e := range mmGetUsersByIDs.GetUsersByIDsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.params
		mm_got := FamilySubClientMockGetUsersByIDsParams{ctx, gp1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUsersByIDs.t.Errorf("FamilySubClientMock.GetUsersByIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUsersByIDs.t.Fatal("No results are set for the FamilySubClientMock.GetUsersByIDs")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetUsersByIDs.funcGetUsersByIDs != nil {
		return mmGetUsersByIDs.funcGetUsersByIDs(ctx, gp1, p1...)
	}
	mmGetUsersByIDs.t.Fatalf("Unexpected call to FamilySubClientMock.GetUsersByIDs. %v %v %v", ctx, gp1, p1)
	return
}

// GetUsersByIDsAfterCounter returns a count of finished FamilySubClientMock.GetUsersByIDs invocations
func (mmGetUsersByIDs *FamilySubClientMock) GetUsersByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByIDs.afterGetUsersByIDsCounter)
}

// GetUsersByIDsBeforeCounter returns a count of FamilySubClientMock.GetUsersByIDs invocations
func (mmGetUsersByIDs *FamilySubClientMock) GetUsersByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByIDs.beforeGetUsersByIDsCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.GetUsersByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUsersByIDs *mFamilySubClientMockGetUsersByIDs) Calls() []*FamilySubClientMockGetUsersByIDsParams {
	mmGetUsersByIDs.mutex.RLock()

	argCopy := make([]*FamilySubClientMockGetUsersByIDsParams, len(mmGetUsersByIDs.callArgs))
	copy(argCopy, mmGetUsersByIDs.callArgs)

	mmGetUsersByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetUsersByIDsDone returns true if the count of the GetUsersByIDs invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockGetUsersByIDsDone() bool {
	for _, e := range m.GetUsersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByIDs != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUsersByIDsInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockGetUsersByIDsInspect() {
	for _, e := range m.GetUsersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.GetUsersByIDs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		if m.GetUsersByIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.GetUsersByIDs")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.GetUsersByIDs with params: %#v", *m.GetUsersByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByIDs != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.GetUsersByIDs")
	}
}

type mFamilySubClientMockReadSubscriber struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockReadSubscriberExpectation
	expectations       []*FamilySubClientMockReadSubscriberExpectation

	callArgs []*FamilySubClientMockReadSubscriberParams
	mutex    sync.RWMutex
}

// FamilySubClientMockReadSubscriberExpectation specifies expectation struct of the FamilySubClient.ReadSubscriber
type FamilySubClientMockReadSubscriberExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockReadSubscriberParams
	results *FamilySubClientMockReadSubscriberResults
	Counter uint64
}

// FamilySubClientMockReadSubscriberParams contains parameters of the FamilySubClient.ReadSubscriber
type FamilySubClientMockReadSubscriberParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockReadSubscriberResults contains results of the FamilySubClient.ReadSubscriber
type FamilySubClientMockReadSubscriberResults struct {
	sp1 *api.Subscriber
	err error
}

// Expect sets up expected params for FamilySubClient.ReadSubscriber
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockReadSubscriber {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("FamilySubClientMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &FamilySubClientMockReadSubscriberExpectation{}
	}

	mmReadSubscriber.defaultExpectation.params = &FamilySubClientMockReadSubscriberParams{ctx, ip1, p1}
	for _, e := range mmReadSubscriber.expectations {
		if minimock.Equal(e.params, mmReadSubscriber.defaultExpectation.params) {
			mmReadSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscriber.defaultExpectation.params)
		}
	}

	return mmReadSubscriber
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.ReadSubscriber
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockReadSubscriber {
	if mmReadSubscriber.mock.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.ReadSubscriber")
	}

	mmReadSubscriber.mock.inspectFuncReadSubscriber = f

	return mmReadSubscriber
}

// Return sets up results that will be returned by FamilySubClient.ReadSubscriber
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) Return(sp1 *api.Subscriber, err error) *FamilySubClientMock {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("FamilySubClientMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &FamilySubClientMockReadSubscriberExpectation{mock: mmReadSubscriber.mock}
	}
	mmReadSubscriber.defaultExpectation.results = &FamilySubClientMockReadSubscriberResults{sp1, err}
	return mmReadSubscriber.mock
}

//Set uses given function f to mock the FamilySubClient.ReadSubscriber method
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscriber, err error)) *FamilySubClientMock {
	if mmReadSubscriber.defaultExpectation != nil {
		mmReadSubscriber.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.ReadSubscriber method")
	}

	if len(mmReadSubscriber.expectations) > 0 {
		mmReadSubscriber.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.ReadSubscriber method")
	}

	mmReadSubscriber.mock.funcReadSubscriber = f
	return mmReadSubscriber.mock
}

// When sets expectation for the FamilySubClient.ReadSubscriber which will trigger the result defined by the following
// Then helper
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockReadSubscriberExpectation {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("FamilySubClientMock.ReadSubscriber mock is already set by Set")
	}

	expectation := &FamilySubClientMockReadSubscriberExpectation{
		mock:   mmReadSubscriber.mock,
		params: &FamilySubClientMockReadSubscriberParams{ctx, ip1, p1},
	}
	mmReadSubscriber.expectations = append(mmReadSubscriber.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.ReadSubscriber return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockReadSubscriberExpectation) Then(sp1 *api.Subscriber, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockReadSubscriberResults{sp1, err}
	return e.mock
}

// ReadSubscriber implements FamilySubClient
func (mmReadSubscriber *FamilySubClientMock) ReadSubscriber(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscriber, err error) {
	mm_atomic.AddUint64(&mmReadSubscriber.beforeReadSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscriber.afterReadSubscriberCounter, 1)

	if mmReadSubscriber.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.inspectFuncReadSubscriber(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockReadSubscriberParams{ctx, ip1, p1}

	// Record call args
	mmReadSubscriber.ReadSubscriberMock.mutex.Lock()
	mmReadSubscriber.ReadSubscriberMock.callArgs = append(mmReadSubscriber.ReadSubscriberMock.callArgs, mm_params)
	mmReadSubscriber.ReadSubscriberMock.mutex.Unlock()

	for _, e := range mmReadSubscriber.ReadSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmReadSubscriber.ReadSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscriber.ReadSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.params
		mm_got := FamilySubClientMockReadSubscriberParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscriber.t.Errorf("FamilySubClientMock.ReadSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscriber.t.Fatal("No results are set for the FamilySubClientMock.ReadSubscriber")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmReadSubscriber.funcReadSubscriber != nil {
		return mmReadSubscriber.funcReadSubscriber(ctx, ip1, p1...)
	}
	mmReadSubscriber.t.Fatalf("Unexpected call to FamilySubClientMock.ReadSubscriber. %v %v %v", ctx, ip1, p1)
	return
}

// ReadSubscriberAfterCounter returns a count of finished FamilySubClientMock.ReadSubscriber invocations
func (mmReadSubscriber *FamilySubClientMock) ReadSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.afterReadSubscriberCounter)
}

// ReadSubscriberBeforeCounter returns a count of FamilySubClientMock.ReadSubscriber invocations
func (mmReadSubscriber *FamilySubClientMock) ReadSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.beforeReadSubscriberCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.ReadSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscriber *mFamilySubClientMockReadSubscriber) Calls() []*FamilySubClientMockReadSubscriberParams {
	mmReadSubscriber.mutex.RLock()

	argCopy := make([]*FamilySubClientMockReadSubscriberParams, len(mmReadSubscriber.callArgs))
	copy(argCopy, mmReadSubscriber.callArgs)

	mmReadSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriberDone returns true if the count of the ReadSubscriber invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockReadSubscriberDone() bool {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriberInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockReadSubscriberInspect() {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		if m.ReadSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.ReadSubscriber")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadSubscriber with params: %#v", *m.ReadSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.ReadSubscriber")
	}
}

type mFamilySubClientMockReadSubscription struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockReadSubscriptionExpectation
	expectations       []*FamilySubClientMockReadSubscriptionExpectation

	callArgs []*FamilySubClientMockReadSubscriptionParams
	mutex    sync.RWMutex
}

// FamilySubClientMockReadSubscriptionExpectation specifies expectation struct of the FamilySubClient.ReadSubscription
type FamilySubClientMockReadSubscriptionExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockReadSubscriptionParams
	results *FamilySubClientMockReadSubscriptionResults
	Counter uint64
}

// FamilySubClientMockReadSubscriptionParams contains parameters of the FamilySubClient.ReadSubscription
type FamilySubClientMockReadSubscriptionParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockReadSubscriptionResults contains results of the FamilySubClient.ReadSubscription
type FamilySubClientMockReadSubscriptionResults struct {
	sp1 *api.Subscription
	err error
}

// Expect sets up expected params for FamilySubClient.ReadSubscription
func (mmReadSubscription *mFamilySubClientMockReadSubscription) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockReadSubscription {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("FamilySubClientMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &FamilySubClientMockReadSubscriptionExpectation{}
	}

	mmReadSubscription.defaultExpectation.params = &FamilySubClientMockReadSubscriptionParams{ctx, ip1, p1}
	for _, e := range mmReadSubscription.expectations {
		if minimock.Equal(e.params, mmReadSubscription.defaultExpectation.params) {
			mmReadSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscription.defaultExpectation.params)
		}
	}

	return mmReadSubscription
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.ReadSubscription
func (mmReadSubscription *mFamilySubClientMockReadSubscription) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockReadSubscription {
	if mmReadSubscription.mock.inspectFuncReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.ReadSubscription")
	}

	mmReadSubscription.mock.inspectFuncReadSubscription = f

	return mmReadSubscription
}

// Return sets up results that will be returned by FamilySubClient.ReadSubscription
func (mmReadSubscription *mFamilySubClientMockReadSubscription) Return(sp1 *api.Subscription, err error) *FamilySubClientMock {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("FamilySubClientMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &FamilySubClientMockReadSubscriptionExpectation{mock: mmReadSubscription.mock}
	}
	mmReadSubscription.defaultExpectation.results = &FamilySubClientMockReadSubscriptionResults{sp1, err}
	return mmReadSubscription.mock
}

//Set uses given function f to mock the FamilySubClient.ReadSubscription method
func (mmReadSubscription *mFamilySubClientMockReadSubscription) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscription, err error)) *FamilySubClientMock {
	if mmReadSubscription.defaultExpectation != nil {
		mmReadSubscription.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.ReadSubscription method")
	}

	if len(mmReadSubscription.expectations) > 0 {
		mmReadSubscription.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.ReadSubscription method")
	}

	mmReadSubscription.mock.funcReadSubscription = f
	return mmReadSubscription.mock
}

// When sets expectation for the FamilySubClient.ReadSubscription which will trigger the result defined by the following
// Then helper
func (mmReadSubscription *mFamilySubClientMockReadSubscription) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockReadSubscriptionExpectation {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("FamilySubClientMock.ReadSubscription mock is already set by Set")
	}

	expectation := &FamilySubClientMockReadSubscriptionExpectation{
		mock:   mmReadSubscription.mock,
		params: &FamilySubClientMockReadSubscriptionParams{ctx, ip1, p1},
	}
	mmReadSubscription.expectations = append(mmReadSubscription.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.ReadSubscription return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockReadSubscriptionExpectation) Then(sp1 *api.Subscription, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockReadSubscriptionResults{sp1, err}
	return e.mock
}

// ReadSubscription implements FamilySubClient
func (mmReadSubscription *FamilySubClientMock) ReadSubscription(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (sp1 *api.Subscription, err error) {
	mm_atomic.AddUint64(&mmReadSubscription.beforeReadSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscription.afterReadSubscriptionCounter, 1)

	if mmReadSubscription.inspectFuncReadSubscription != nil {
		mmReadSubscription.inspectFuncReadSubscription(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockReadSubscriptionParams{ctx, ip1, p1}

	// Record call args
	mmReadSubscription.ReadSubscriptionMock.mutex.Lock()
	mmReadSubscription.ReadSubscriptionMock.callArgs = append(mmReadSubscription.ReadSubscriptionMock.callArgs, mm_params)
	mmReadSubscription.ReadSubscriptionMock.mutex.Unlock()

	for _, e := range mmReadSubscription.ReadSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmReadSubscription.ReadSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscription.ReadSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.params
		mm_got := FamilySubClientMockReadSubscriptionParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscription.t.Errorf("FamilySubClientMock.ReadSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscription.t.Fatal("No results are set for the FamilySubClientMock.ReadSubscription")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmReadSubscription.funcReadSubscription != nil {
		return mmReadSubscription.funcReadSubscription(ctx, ip1, p1...)
	}
	mmReadSubscription.t.Fatalf("Unexpected call to FamilySubClientMock.ReadSubscription. %v %v %v", ctx, ip1, p1)
	return
}

// ReadSubscriptionAfterCounter returns a count of finished FamilySubClientMock.ReadSubscription invocations
func (mmReadSubscription *FamilySubClientMock) ReadSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.afterReadSubscriptionCounter)
}

// ReadSubscriptionBeforeCounter returns a count of FamilySubClientMock.ReadSubscription invocations
func (mmReadSubscription *FamilySubClientMock) ReadSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.beforeReadSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.ReadSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscription *mFamilySubClientMockReadSubscription) Calls() []*FamilySubClientMockReadSubscriptionParams {
	mmReadSubscription.mutex.RLock()

	argCopy := make([]*FamilySubClientMockReadSubscriptionParams, len(mmReadSubscription.callArgs))
	copy(argCopy, mmReadSubscription.callArgs)

	mmReadSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriptionDone returns true if the count of the ReadSubscription invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockReadSubscriptionDone() bool {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriptionInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockReadSubscriptionInspect() {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		if m.ReadSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.ReadSubscription")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadSubscription with params: %#v", *m.ReadSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.ReadSubscription")
	}
}

type mFamilySubClientMockReadUser struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockReadUserExpectation
	expectations       []*FamilySubClientMockReadUserExpectation

	callArgs []*FamilySubClientMockReadUserParams
	mutex    sync.RWMutex
}

// FamilySubClientMockReadUserExpectation specifies expectation struct of the FamilySubClient.ReadUser
type FamilySubClientMockReadUserExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockReadUserParams
	results *FamilySubClientMockReadUserResults
	Counter uint64
}

// FamilySubClientMockReadUserParams contains parameters of the FamilySubClient.ReadUser
type FamilySubClientMockReadUserParams struct {
	ctx context.Context
	ip1 *api.ID
	p1  []grpc.CallOption
}

// FamilySubClientMockReadUserResults contains results of the FamilySubClient.ReadUser
type FamilySubClientMockReadUserResults struct {
	up1 *api.User
	err error
}

// Expect sets up expected params for FamilySubClient.ReadUser
func (mmReadUser *mFamilySubClientMockReadUser) Expect(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *mFamilySubClientMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("FamilySubClientMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &FamilySubClientMockReadUserExpectation{}
	}

	mmReadUser.defaultExpectation.params = &FamilySubClientMockReadUserParams{ctx, ip1, p1}
	for _, e := range mmReadUser.expectations {
		if minimock.Equal(e.params, mmReadUser.defaultExpectation.params) {
			mmReadUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadUser.defaultExpectation.params)
		}
	}

	return mmReadUser
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.ReadUser
func (mmReadUser *mFamilySubClientMockReadUser) Inspect(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption)) *mFamilySubClientMockReadUser {
	if mmReadUser.mock.inspectFuncReadUser != nil {
		mmReadUser.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.ReadUser")
	}

	mmReadUser.mock.inspectFuncReadUser = f

	return mmReadUser
}

// Return sets up results that will be returned by FamilySubClient.ReadUser
func (mmReadUser *mFamilySubClientMockReadUser) Return(up1 *api.User, err error) *FamilySubClientMock {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("FamilySubClientMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &FamilySubClientMockReadUserExpectation{mock: mmReadUser.mock}
	}
	mmReadUser.defaultExpectation.results = &FamilySubClientMockReadUserResults{up1, err}
	return mmReadUser.mock
}

//Set uses given function f to mock the FamilySubClient.ReadUser method
func (mmReadUser *mFamilySubClientMockReadUser) Set(f func(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error)) *FamilySubClientMock {
	if mmReadUser.defaultExpectation != nil {
		mmReadUser.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.ReadUser method")
	}

	if len(mmReadUser.expectations) > 0 {
		mmReadUser.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.ReadUser method")
	}

	mmReadUser.mock.funcReadUser = f
	return mmReadUser.mock
}

// When sets expectation for the FamilySubClient.ReadUser which will trigger the result defined by the following
// Then helper
func (mmReadUser *mFamilySubClientMockReadUser) When(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) *FamilySubClientMockReadUserExpectation {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("FamilySubClientMock.ReadUser mock is already set by Set")
	}

	expectation := &FamilySubClientMockReadUserExpectation{
		mock:   mmReadUser.mock,
		params: &FamilySubClientMockReadUserParams{ctx, ip1, p1},
	}
	mmReadUser.expectations = append(mmReadUser.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.ReadUser return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockReadUserExpectation) Then(up1 *api.User, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockReadUserResults{up1, err}
	return e.mock
}

// ReadUser implements FamilySubClient
func (mmReadUser *FamilySubClientMock) ReadUser(ctx context.Context, ip1 *api.ID, p1 ...grpc.CallOption) (up1 *api.User, err error) {
	mm_atomic.AddUint64(&mmReadUser.beforeReadUserCounter, 1)
	defer mm_atomic.AddUint64(&mmReadUser.afterReadUserCounter, 1)

	if mmReadUser.inspectFuncReadUser != nil {
		mmReadUser.inspectFuncReadUser(ctx, ip1, p1...)
	}

	mm_params := &FamilySubClientMockReadUserParams{ctx, ip1, p1}

	// Record call args
	mmReadUser.ReadUserMock.mutex.Lock()
	mmReadUser.ReadUserMock.callArgs = append(mmReadUser.ReadUserMock.callArgs, mm_params)
	mmReadUser.ReadUserMock.mutex.Unlock()

	for _, e := range mmReadUser.ReadUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmReadUser.ReadUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadUser.ReadUserMock.defaultExpectation.Counter, 1)
		mm_want := mmReadUser.ReadUserMock.defaultExpectation.params
		mm_got := FamilySubClientMockReadUserParams{ctx, ip1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadUser.t.Errorf("FamilySubClientMock.ReadUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadUser.ReadUserMock.defaultExpectation.results
		if mm_results == nil {
			mmReadUser.t.Fatal("No results are set for the FamilySubClientMock.ReadUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmReadUser.funcReadUser != nil {
		return mmReadUser.funcReadUser(ctx, ip1, p1...)
	}
	mmReadUser.t.Fatalf("Unexpected call to FamilySubClientMock.ReadUser. %v %v %v", ctx, ip1, p1)
	return
}

// ReadUserAfterCounter returns a count of finished FamilySubClientMock.ReadUser invocations
func (mmReadUser *FamilySubClientMock) ReadUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.afterReadUserCounter)
}

// ReadUserBeforeCounter returns a count of FamilySubClientMock.ReadUser invocations
func (mmReadUser *FamilySubClientMock) ReadUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.beforeReadUserCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.ReadUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadUser *mFamilySubClientMockReadUser) Calls() []*FamilySubClientMockReadUserParams {
	mmReadUser.mutex.RLock()

	argCopy := make([]*FamilySubClientMockReadUserParams, len(mmReadUser.callArgs))
	copy(argCopy, mmReadUser.callArgs)

	mmReadUser.mutex.RUnlock()

	return argCopy
}

// MinimockReadUserDone returns true if the count of the ReadUser invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockReadUserDone() bool {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadUserInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockReadUserInspect() {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		if m.ReadUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.ReadUser")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.ReadUser with params: %#v", *m.ReadUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.ReadUser")
	}
}

type mFamilySubClientMockUpdateSubscriber struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockUpdateSubscriberExpectation
	expectations       []*FamilySubClientMockUpdateSubscriberExpectation

	callArgs []*FamilySubClientMockUpdateSubscriberParams
	mutex    sync.RWMutex
}

// FamilySubClientMockUpdateSubscriberExpectation specifies expectation struct of the FamilySubClient.UpdateSubscriber
type FamilySubClientMockUpdateSubscriberExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockUpdateSubscriberParams
	results *FamilySubClientMockUpdateSubscriberResults
	Counter uint64
}

// FamilySubClientMockUpdateSubscriberParams contains parameters of the FamilySubClient.UpdateSubscriber
type FamilySubClientMockUpdateSubscriberParams struct {
	ctx context.Context
	sp1 *api.Subscriber
	p1  []grpc.CallOption
}

// FamilySubClientMockUpdateSubscriberResults contains results of the FamilySubClient.UpdateSubscriber
type FamilySubClientMockUpdateSubscriberResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.UpdateSubscriber
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) Expect(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) *mFamilySubClientMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("FamilySubClientMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &FamilySubClientMockUpdateSubscriberExpectation{}
	}

	mmUpdateSubscriber.defaultExpectation.params = &FamilySubClientMockUpdateSubscriberParams{ctx, sp1, p1}
	for _, e := range mmUpdateSubscriber.expectations {
		if minimock.Equal(e.params, mmUpdateSubscriber.defaultExpectation.params) {
			mmUpdateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscriber.defaultExpectation.params)
		}
	}

	return mmUpdateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.UpdateSubscriber
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) Inspect(f func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption)) *mFamilySubClientMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.UpdateSubscriber")
	}

	mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber = f

	return mmUpdateSubscriber
}

// Return sets up results that will be returned by FamilySubClient.UpdateSubscriber
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("FamilySubClientMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &FamilySubClientMockUpdateSubscriberExpectation{mock: mmUpdateSubscriber.mock}
	}
	mmUpdateSubscriber.defaultExpectation.results = &FamilySubClientMockUpdateSubscriberResults{ep1, err}
	return mmUpdateSubscriber.mock
}

//Set uses given function f to mock the FamilySubClient.UpdateSubscriber method
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) Set(f func(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmUpdateSubscriber.defaultExpectation != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.UpdateSubscriber method")
	}

	if len(mmUpdateSubscriber.expectations) > 0 {
		mmUpdateSubscriber.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.UpdateSubscriber method")
	}

	mmUpdateSubscriber.mock.funcUpdateSubscriber = f
	return mmUpdateSubscriber.mock
}

// When sets expectation for the FamilySubClient.UpdateSubscriber which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) When(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) *FamilySubClientMockUpdateSubscriberExpectation {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("FamilySubClientMock.UpdateSubscriber mock is already set by Set")
	}

	expectation := &FamilySubClientMockUpdateSubscriberExpectation{
		mock:   mmUpdateSubscriber.mock,
		params: &FamilySubClientMockUpdateSubscriberParams{ctx, sp1, p1},
	}
	mmUpdateSubscriber.expectations = append(mmUpdateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.UpdateSubscriber return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockUpdateSubscriberExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockUpdateSubscriberResults{ep1, err}
	return e.mock
}

// UpdateSubscriber implements FamilySubClient
func (mmUpdateSubscriber *FamilySubClientMock) UpdateSubscriber(ctx context.Context, sp1 *api.Subscriber, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter, 1)

	if mmUpdateSubscriber.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.inspectFuncUpdateSubscriber(ctx, sp1, p1...)
	}

	mm_params := &FamilySubClientMockUpdateSubscriberParams{ctx, sp1, p1}

	// Record call args
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Lock()
	mmUpdateSubscriber.UpdateSubscriberMock.callArgs = append(mmUpdateSubscriber.UpdateSubscriberMock.callArgs, mm_params)
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Unlock()

	for _, e := range mmUpdateSubscriber.UpdateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.params
		mm_got := FamilySubClientMockUpdateSubscriberParams{ctx, sp1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscriber.t.Errorf("FamilySubClientMock.UpdateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscriber.t.Fatal("No results are set for the FamilySubClientMock.UpdateSubscriber")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmUpdateSubscriber.funcUpdateSubscriber != nil {
		return mmUpdateSubscriber.funcUpdateSubscriber(ctx, sp1, p1...)
	}
	mmUpdateSubscriber.t.Fatalf("Unexpected call to FamilySubClientMock.UpdateSubscriber. %v %v %v", ctx, sp1, p1)
	return
}

// UpdateSubscriberAfterCounter returns a count of finished FamilySubClientMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *FamilySubClientMock) UpdateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter)
}

// UpdateSubscriberBeforeCounter returns a count of FamilySubClientMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *FamilySubClientMock) UpdateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.UpdateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscriber *mFamilySubClientMockUpdateSubscriber) Calls() []*FamilySubClientMockUpdateSubscriberParams {
	mmUpdateSubscriber.mutex.RLock()

	argCopy := make([]*FamilySubClientMockUpdateSubscriberParams, len(mmUpdateSubscriber.callArgs))
	copy(argCopy, mmUpdateSubscriber.callArgs)

	mmUpdateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriberDone returns true if the count of the UpdateSubscriber invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockUpdateSubscriberDone() bool {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriberInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockUpdateSubscriberInspect() {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		if m.UpdateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.UpdateSubscriber")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateSubscriber with params: %#v", *m.UpdateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.UpdateSubscriber")
	}
}

type mFamilySubClientMockUpdateSubscription struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockUpdateSubscriptionExpectation
	expectations       []*FamilySubClientMockUpdateSubscriptionExpectation

	callArgs []*FamilySubClientMockUpdateSubscriptionParams
	mutex    sync.RWMutex
}

// FamilySubClientMockUpdateSubscriptionExpectation specifies expectation struct of the FamilySubClient.UpdateSubscription
type FamilySubClientMockUpdateSubscriptionExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockUpdateSubscriptionParams
	results *FamilySubClientMockUpdateSubscriptionResults
	Counter uint64
}

// FamilySubClientMockUpdateSubscriptionParams contains parameters of the FamilySubClient.UpdateSubscription
type FamilySubClientMockUpdateSubscriptionParams struct {
	ctx context.Context
	sp1 *api.Subscription
	p1  []grpc.CallOption
}

// FamilySubClientMockUpdateSubscriptionResults contains results of the FamilySubClient.UpdateSubscription
type FamilySubClientMockUpdateSubscriptionResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.UpdateSubscription
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) Expect(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) *mFamilySubClientMockUpdateSubscription {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("FamilySubClientMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &FamilySubClientMockUpdateSubscriptionExpectation{}
	}

	mmUpdateSubscription.defaultExpectation.params = &FamilySubClientMockUpdateSubscriptionParams{ctx, sp1, p1}
	for _, e := range mmUpdateSubscription.expectations {
		if minimock.Equal(e.params, mmUpdateSubscription.defaultExpectation.params) {
			mmUpdateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscription.defaultExpectation.params)
		}
	}

	return mmUpdateSubscription
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.UpdateSubscription
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) Inspect(f func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption)) *mFamilySubClientMockUpdateSubscription {
	if mmUpdateSubscription.mock.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.UpdateSubscription")
	}

	mmUpdateSubscription.mock.inspectFuncUpdateSubscription = f

	return mmUpdateSubscription
}

// Return sets up results that will be returned by FamilySubClient.UpdateSubscription
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("FamilySubClientMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &FamilySubClientMockUpdateSubscriptionExpectation{mock: mmUpdateSubscription.mock}
	}
	mmUpdateSubscription.defaultExpectation.results = &FamilySubClientMockUpdateSubscriptionResults{ep1, err}
	return mmUpdateSubscription.mock
}

//Set uses given function f to mock the FamilySubClient.UpdateSubscription method
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) Set(f func(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmUpdateSubscription.defaultExpectation != nil {
		mmUpdateSubscription.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.UpdateSubscription method")
	}

	if len(mmUpdateSubscription.expectations) > 0 {
		mmUpdateSubscription.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.UpdateSubscription method")
	}

	mmUpdateSubscription.mock.funcUpdateSubscription = f
	return mmUpdateSubscription.mock
}

// When sets expectation for the FamilySubClient.UpdateSubscription which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) When(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) *FamilySubClientMockUpdateSubscriptionExpectation {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("FamilySubClientMock.UpdateSubscription mock is already set by Set")
	}

	expectation := &FamilySubClientMockUpdateSubscriptionExpectation{
		mock:   mmUpdateSubscription.mock,
		params: &FamilySubClientMockUpdateSubscriptionParams{ctx, sp1, p1},
	}
	mmUpdateSubscription.expectations = append(mmUpdateSubscription.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.UpdateSubscription return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockUpdateSubscriptionExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockUpdateSubscriptionResults{ep1, err}
	return e.mock
}

// UpdateSubscription implements FamilySubClient
func (mmUpdateSubscription *FamilySubClientMock) UpdateSubscription(ctx context.Context, sp1 *api.Subscription, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter, 1)

	if mmUpdateSubscription.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.inspectFuncUpdateSubscription(ctx, sp1, p1...)
	}

	mm_params := &FamilySubClientMockUpdateSubscriptionParams{ctx, sp1, p1}

	// Record call args
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Lock()
	mmUpdateSubscription.UpdateSubscriptionMock.callArgs = append(mmUpdateSubscription.UpdateSubscriptionMock.callArgs, mm_params)
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Unlock()

	for _, e := range mmUpdateSubscription.UpdateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.params
		mm_got := FamilySubClientMockUpdateSubscriptionParams{ctx, sp1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscription.t.Errorf("FamilySubClientMock.UpdateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscription.t.Fatal("No results are set for the FamilySubClientMock.UpdateSubscription")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmUpdateSubscription.funcUpdateSubscription != nil {
		return mmUpdateSubscription.funcUpdateSubscription(ctx, sp1, p1...)
	}
	mmUpdateSubscription.t.Fatalf("Unexpected call to FamilySubClientMock.UpdateSubscription. %v %v %v", ctx, sp1, p1)
	return
}

// UpdateSubscriptionAfterCounter returns a count of finished FamilySubClientMock.UpdateSubscription invocations
func (mmUpdateSubscription *FamilySubClientMock) UpdateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter)
}

// UpdateSubscriptionBeforeCounter returns a count of FamilySubClientMock.UpdateSubscription invocations
func (mmUpdateSubscription *FamilySubClientMock) UpdateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.UpdateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscription *mFamilySubClientMockUpdateSubscription) Calls() []*FamilySubClientMockUpdateSubscriptionParams {
	mmUpdateSubscription.mutex.RLock()

	argCopy := make([]*FamilySubClientMockUpdateSubscriptionParams, len(mmUpdateSubscription.callArgs))
	copy(argCopy, mmUpdateSubscription.callArgs)

	mmUpdateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriptionDone returns true if the count of the UpdateSubscription invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockUpdateSubscriptionDone() bool {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriptionInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockUpdateSubscriptionInspect() {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		if m.UpdateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.UpdateSubscription")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateSubscription with params: %#v", *m.UpdateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.UpdateSubscription")
	}
}

type mFamilySubClientMockUpdateUser struct {
	mock               *FamilySubClientMock
	defaultExpectation *FamilySubClientMockUpdateUserExpectation
	expectations       []*FamilySubClientMockUpdateUserExpectation

	callArgs []*FamilySubClientMockUpdateUserParams
	mutex    sync.RWMutex
}

// FamilySubClientMockUpdateUserExpectation specifies expectation struct of the FamilySubClient.UpdateUser
type FamilySubClientMockUpdateUserExpectation struct {
	mock    *FamilySubClientMock
	params  *FamilySubClientMockUpdateUserParams
	results *FamilySubClientMockUpdateUserResults
	Counter uint64
}

// FamilySubClientMockUpdateUserParams contains parameters of the FamilySubClient.UpdateUser
type FamilySubClientMockUpdateUserParams struct {
	ctx context.Context
	up1 *api.User
	p1  []grpc.CallOption
}

// FamilySubClientMockUpdateUserResults contains results of the FamilySubClient.UpdateUser
type FamilySubClientMockUpdateUserResults struct {
	ep1 *empty.Empty
	err error
}

// Expect sets up expected params for FamilySubClient.UpdateUser
func (mmUpdateUser *mFamilySubClientMockUpdateUser) Expect(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) *mFamilySubClientMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("FamilySubClientMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &FamilySubClientMockUpdateUserExpectation{}
	}

	mmUpdateUser.defaultExpectation.params = &FamilySubClientMockUpdateUserParams{ctx, up1, p1}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the FamilySubClient.UpdateUser
func (mmUpdateUser *mFamilySubClientMockUpdateUser) Inspect(f func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption)) *mFamilySubClientMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for FamilySubClientMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by FamilySubClient.UpdateUser
func (mmUpdateUser *mFamilySubClientMockUpdateUser) Return(ep1 *empty.Empty, err error) *FamilySubClientMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("FamilySubClientMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &FamilySubClientMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &FamilySubClientMockUpdateUserResults{ep1, err}
	return mmUpdateUser.mock
}

//Set uses given function f to mock the FamilySubClient.UpdateUser method
func (mmUpdateUser *mFamilySubClientMockUpdateUser) Set(f func(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error)) *FamilySubClientMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the FamilySubClient.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the FamilySubClient.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the FamilySubClient.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mFamilySubClientMockUpdateUser) When(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) *FamilySubClientMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("FamilySubClientMock.UpdateUser mock is already set by Set")
	}

	expectation := &FamilySubClientMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &FamilySubClientMockUpdateUserParams{ctx, up1, p1},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up FamilySubClient.UpdateUser return parameters for the expectation previously defined by the When method
func (e *FamilySubClientMockUpdateUserExpectation) Then(ep1 *empty.Empty, err error) *FamilySubClientMock {
	e.results = &FamilySubClientMockUpdateUserResults{ep1, err}
	return e.mock
}

// UpdateUser implements FamilySubClient
func (mmUpdateUser *FamilySubClientMock) UpdateUser(ctx context.Context, up1 *api.User, p1 ...grpc.CallOption) (ep1 *empty.Empty, err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, up1, p1...)
	}

	mm_params := &FamilySubClientMockUpdateUserParams{ctx, up1, p1}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ep1, e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_got := FamilySubClientMockUpdateUserParams{ctx, up1, p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("FamilySubClientMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the FamilySubClientMock.UpdateUser")
		}
		return (*mm_results).ep1, (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, up1, p1...)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to FamilySubClientMock.UpdateUser. %v %v %v", ctx, up1, p1)
	return
}

// UpdateUserAfterCounter returns a count of finished FamilySubClientMock.UpdateUser invocations
func (mmUpdateUser *FamilySubClientMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of FamilySubClientMock.UpdateUser invocations
func (mmUpdateUser *FamilySubClientMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to FamilySubClientMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mFamilySubClientMockUpdateUser) Calls() []*FamilySubClientMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*FamilySubClientMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *FamilySubClientMock) MinimockUpdateUserDone() bool {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *FamilySubClientMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FamilySubClientMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to FamilySubClientMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		m.t.Error("Expected call to FamilySubClientMock.UpdateUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FamilySubClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSubscriberInspect()

		m.MinimockCreateSubscriptionInspect()

		m.MinimockCreateUserInspect()

		m.MinimockDeleteSubscriberInspect()

		m.MinimockDeleteSubscriptionInspect()

		m.MinimockDeleteUserInspect()

		m.MinimockGetSubscribersForSubscriptionInspect()

		m.MinimockGetSubscriptionsForUserInspect()

		m.MinimockGetUserByTelegramIDInspect()

		m.MinimockGetUsersByIDsInspect()

		m.MinimockReadSubscriberInspect()

		m.MinimockReadSubscriptionInspect()

		m.MinimockReadUserInspect()

		m.MinimockUpdateSubscriberInspect()

		m.MinimockUpdateSubscriptionInspect()

		m.MinimockUpdateUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FamilySubClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FamilySubClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSubscriberDone() &&
		m.MinimockCreateSubscriptionDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteSubscriberDone() &&
		m.MinimockDeleteSubscriptionDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetSubscribersForSubscriptionDone() &&
		m.MinimockGetSubscriptionsForUserDone() &&
		m.MinimockGetUserByTelegramIDDone() &&
		m.MinimockGetUsersByIDsDone() &&
		m.MinimockReadSubscriberDone() &&
		m.MinimockReadSubscriptionDone() &&
		m.MinimockReadUserDone() &&
		m.MinimockUpdateSubscriberDone() &&
		m.MinimockUpdateSubscriptionDone() &&
		m.MinimockUpdateUserDone()
}
