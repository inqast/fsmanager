package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/inqast/fsmanager/internal/app.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/inqast/fsmanager/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateSubscriber          func(ctx context.Context, s1 models.Subscriber) (i1 int, err error)
	inspectFuncCreateSubscriber   func(ctx context.Context, s1 models.Subscriber)
	afterCreateSubscriberCounter  uint64
	beforeCreateSubscriberCounter uint64
	CreateSubscriberMock          mRepositoryMockCreateSubscriber

	funcCreateSubscription          func(ctx context.Context, s1 models.Subscription) (i1 int, err error)
	inspectFuncCreateSubscription   func(ctx context.Context, s1 models.Subscription)
	afterCreateSubscriptionCounter  uint64
	beforeCreateSubscriptionCounter uint64
	CreateSubscriptionMock          mRepositoryMockCreateSubscription

	funcCreateUser          func(ctx context.Context, u1 models.User) (i1 int, err error)
	inspectFuncCreateUser   func(ctx context.Context, u1 models.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcDeleteSubscriber          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteSubscriber   func(ctx context.Context, i1 int)
	afterDeleteSubscriberCounter  uint64
	beforeDeleteSubscriberCounter uint64
	DeleteSubscriberMock          mRepositoryMockDeleteSubscriber

	funcDeleteSubscription          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteSubscription   func(ctx context.Context, i1 int)
	afterDeleteSubscriptionCounter  uint64
	beforeDeleteSubscriptionCounter uint64
	DeleteSubscriptionMock          mRepositoryMockDeleteSubscription

	funcDeleteUser          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, i1 int)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mRepositoryMockDeleteUser

	funcGetSubscribers          func(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error)
	inspectFuncGetSubscribers   func(ctx context.Context, i1 int)
	afterGetSubscribersCounter  uint64
	beforeGetSubscribersCounter uint64
	GetSubscribersMock          mRepositoryMockGetSubscribers

	funcGetSubscriptions          func(ctx context.Context, i1 int) (sa1 []models.Subscription, err error)
	inspectFuncGetSubscriptions   func(ctx context.Context, i1 int)
	afterGetSubscriptionsCounter  uint64
	beforeGetSubscriptionsCounter uint64
	GetSubscriptionsMock          mRepositoryMockGetSubscriptions

	funcReadSubscriber          func(ctx context.Context, i1 int) (s1 models.Subscriber, err error)
	inspectFuncReadSubscriber   func(ctx context.Context, i1 int)
	afterReadSubscriberCounter  uint64
	beforeReadSubscriberCounter uint64
	ReadSubscriberMock          mRepositoryMockReadSubscriber

	funcReadSubscription          func(ctx context.Context, i1 int) (s1 models.Subscription, err error)
	inspectFuncReadSubscription   func(ctx context.Context, i1 int)
	afterReadSubscriptionCounter  uint64
	beforeReadSubscriptionCounter uint64
	ReadSubscriptionMock          mRepositoryMockReadSubscription

	funcReadUser          func(ctx context.Context, i1 int) (u1 models.User, err error)
	inspectFuncReadUser   func(ctx context.Context, i1 int)
	afterReadUserCounter  uint64
	beforeReadUserCounter uint64
	ReadUserMock          mRepositoryMockReadUser

	funcUpdateSubscriber          func(ctx context.Context, s1 models.Subscriber) (err error)
	inspectFuncUpdateSubscriber   func(ctx context.Context, s1 models.Subscriber)
	afterUpdateSubscriberCounter  uint64
	beforeUpdateSubscriberCounter uint64
	UpdateSubscriberMock          mRepositoryMockUpdateSubscriber

	funcUpdateSubscription          func(ctx context.Context, s1 models.Subscription) (err error)
	inspectFuncUpdateSubscription   func(ctx context.Context, s1 models.Subscription)
	afterUpdateSubscriptionCounter  uint64
	beforeUpdateSubscriptionCounter uint64
	UpdateSubscriptionMock          mRepositoryMockUpdateSubscription

	funcUpdateUser          func(ctx context.Context, u1 models.User) (err error)
	inspectFuncUpdateUser   func(ctx context.Context, u1 models.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mRepositoryMockUpdateUser
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSubscriberMock = mRepositoryMockCreateSubscriber{mock: m}
	m.CreateSubscriberMock.callArgs = []*RepositoryMockCreateSubscriberParams{}

	m.CreateSubscriptionMock = mRepositoryMockCreateSubscription{mock: m}
	m.CreateSubscriptionMock.callArgs = []*RepositoryMockCreateSubscriptionParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.DeleteSubscriberMock = mRepositoryMockDeleteSubscriber{mock: m}
	m.DeleteSubscriberMock.callArgs = []*RepositoryMockDeleteSubscriberParams{}

	m.DeleteSubscriptionMock = mRepositoryMockDeleteSubscription{mock: m}
	m.DeleteSubscriptionMock.callArgs = []*RepositoryMockDeleteSubscriptionParams{}

	m.DeleteUserMock = mRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*RepositoryMockDeleteUserParams{}

	m.GetSubscribersMock = mRepositoryMockGetSubscribers{mock: m}
	m.GetSubscribersMock.callArgs = []*RepositoryMockGetSubscribersParams{}

	m.GetSubscriptionsMock = mRepositoryMockGetSubscriptions{mock: m}
	m.GetSubscriptionsMock.callArgs = []*RepositoryMockGetSubscriptionsParams{}

	m.ReadSubscriberMock = mRepositoryMockReadSubscriber{mock: m}
	m.ReadSubscriberMock.callArgs = []*RepositoryMockReadSubscriberParams{}

	m.ReadSubscriptionMock = mRepositoryMockReadSubscription{mock: m}
	m.ReadSubscriptionMock.callArgs = []*RepositoryMockReadSubscriptionParams{}

	m.ReadUserMock = mRepositoryMockReadUser{mock: m}
	m.ReadUserMock.callArgs = []*RepositoryMockReadUserParams{}

	m.UpdateSubscriberMock = mRepositoryMockUpdateSubscriber{mock: m}
	m.UpdateSubscriberMock.callArgs = []*RepositoryMockUpdateSubscriberParams{}

	m.UpdateSubscriptionMock = mRepositoryMockUpdateSubscription{mock: m}
	m.UpdateSubscriptionMock.callArgs = []*RepositoryMockUpdateSubscriptionParams{}

	m.UpdateUserMock = mRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*RepositoryMockUpdateUserParams{}

	return m
}

type mRepositoryMockCreateSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSubscriberExpectation
	expectations       []*RepositoryMockCreateSubscriberExpectation

	callArgs []*RepositoryMockCreateSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateSubscriberExpectation specifies expectation struct of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateSubscriberParams
	results *RepositoryMockCreateSubscriberResults
	Counter uint64
}

// RepositoryMockCreateSubscriberParams contains parameters of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberParams struct {
	ctx context.Context
	s1  models.Subscriber
}

// RepositoryMockCreateSubscriberResults contains results of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Expect(ctx context.Context, s1 models.Subscriber) *mRepositoryMockCreateSubscriber {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &RepositoryMockCreateSubscriberExpectation{}
	}

	mmCreateSubscriber.defaultExpectation.params = &RepositoryMockCreateSubscriberParams{ctx, s1}
	for _, e := range mmCreateSubscriber.expectations {
		if minimock.Equal(e.params, mmCreateSubscriber.defaultExpectation.params) {
			mmCreateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscriber.defaultExpectation.params)
		}
	}

	return mmCreateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Inspect(f func(ctx context.Context, s1 models.Subscriber)) *mRepositoryMockCreateSubscriber {
	if mmCreateSubscriber.mock.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSubscriber")
	}

	mmCreateSubscriber.mock.inspectFuncCreateSubscriber = f

	return mmCreateSubscriber
}

// Return sets up results that will be returned by Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Return(i1 int, err error) *RepositoryMock {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &RepositoryMockCreateSubscriberExpectation{mock: mmCreateSubscriber.mock}
	}
	mmCreateSubscriber.defaultExpectation.results = &RepositoryMockCreateSubscriberResults{i1, err}
	return mmCreateSubscriber.mock
}

//Set uses given function f to mock the Repository.CreateSubscriber method
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Set(f func(ctx context.Context, s1 models.Subscriber) (i1 int, err error)) *RepositoryMock {
	if mmCreateSubscriber.defaultExpectation != nil {
		mmCreateSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSubscriber method")
	}

	if len(mmCreateSubscriber.expectations) > 0 {
		mmCreateSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSubscriber method")
	}

	mmCreateSubscriber.mock.funcCreateSubscriber = f
	return mmCreateSubscriber.mock
}

// When sets expectation for the Repository.CreateSubscriber which will trigger the result defined by the following
// Then helper
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) When(ctx context.Context, s1 models.Subscriber) *RepositoryMockCreateSubscriberExpectation {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSubscriberExpectation{
		mock:   mmCreateSubscriber.mock,
		params: &RepositoryMockCreateSubscriberParams{ctx, s1},
	}
	mmCreateSubscriber.expectations = append(mmCreateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSubscriberExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSubscriberResults{i1, err}
	return e.mock
}

// CreateSubscriber implements Repository
func (mmCreateSubscriber *RepositoryMock) CreateSubscriber(ctx context.Context, s1 models.Subscriber) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscriber.afterCreateSubscriberCounter, 1)

	if mmCreateSubscriber.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.inspectFuncCreateSubscriber(ctx, s1)
	}

	mm_params := &RepositoryMockCreateSubscriberParams{ctx, s1}

	// Record call args
	mmCreateSubscriber.CreateSubscriberMock.mutex.Lock()
	mmCreateSubscriber.CreateSubscriberMock.callArgs = append(mmCreateSubscriber.CreateSubscriberMock.callArgs, mm_params)
	mmCreateSubscriber.CreateSubscriberMock.mutex.Unlock()

	for _, e := range mmCreateSubscriber.CreateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateSubscriber.CreateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockCreateSubscriberParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscriber.t.Errorf("RepositoryMock.CreateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscriber.t.Fatal("No results are set for the RepositoryMock.CreateSubscriber")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateSubscriber.funcCreateSubscriber != nil {
		return mmCreateSubscriber.funcCreateSubscriber(ctx, s1)
	}
	mmCreateSubscriber.t.Fatalf("Unexpected call to RepositoryMock.CreateSubscriber. %v %v", ctx, s1)
	return
}

// CreateSubscriberAfterCounter returns a count of finished RepositoryMock.CreateSubscriber invocations
func (mmCreateSubscriber *RepositoryMock) CreateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.afterCreateSubscriberCounter)
}

// CreateSubscriberBeforeCounter returns a count of RepositoryMock.CreateSubscriber invocations
func (mmCreateSubscriber *RepositoryMock) CreateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Calls() []*RepositoryMockCreateSubscriberParams {
	mmCreateSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSubscriberParams, len(mmCreateSubscriber.callArgs))
	copy(argCopy, mmCreateSubscriber.callArgs)

	mmCreateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriberDone returns true if the count of the CreateSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSubscriberDone() bool {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSubscriberInspect() {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		if m.CreateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscriber with params: %#v", *m.CreateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateSubscriber")
	}
}

type mRepositoryMockCreateSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSubscriptionExpectation
	expectations       []*RepositoryMockCreateSubscriptionExpectation

	callArgs []*RepositoryMockCreateSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateSubscriptionExpectation specifies expectation struct of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateSubscriptionParams
	results *RepositoryMockCreateSubscriptionResults
	Counter uint64
}

// RepositoryMockCreateSubscriptionParams contains parameters of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionParams struct {
	ctx context.Context
	s1  models.Subscription
}

// RepositoryMockCreateSubscriptionResults contains results of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Expect(ctx context.Context, s1 models.Subscription) *mRepositoryMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &RepositoryMockCreateSubscriptionExpectation{}
	}

	mmCreateSubscription.defaultExpectation.params = &RepositoryMockCreateSubscriptionParams{ctx, s1}
	for _, e := range mmCreateSubscription.expectations {
		if minimock.Equal(e.params, mmCreateSubscription.defaultExpectation.params) {
			mmCreateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscription.defaultExpectation.params)
		}
	}

	return mmCreateSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Inspect(f func(ctx context.Context, s1 models.Subscription)) *mRepositoryMockCreateSubscription {
	if mmCreateSubscription.mock.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSubscription")
	}

	mmCreateSubscription.mock.inspectFuncCreateSubscription = f

	return mmCreateSubscription
}

// Return sets up results that will be returned by Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Return(i1 int, err error) *RepositoryMock {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &RepositoryMockCreateSubscriptionExpectation{mock: mmCreateSubscription.mock}
	}
	mmCreateSubscription.defaultExpectation.results = &RepositoryMockCreateSubscriptionResults{i1, err}
	return mmCreateSubscription.mock
}

//Set uses given function f to mock the Repository.CreateSubscription method
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Set(f func(ctx context.Context, s1 models.Subscription) (i1 int, err error)) *RepositoryMock {
	if mmCreateSubscription.defaultExpectation != nil {
		mmCreateSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSubscription method")
	}

	if len(mmCreateSubscription.expectations) > 0 {
		mmCreateSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSubscription method")
	}

	mmCreateSubscription.mock.funcCreateSubscription = f
	return mmCreateSubscription.mock
}

// When sets expectation for the Repository.CreateSubscription which will trigger the result defined by the following
// Then helper
func (mmCreateSubscription *mRepositoryMockCreateSubscription) When(ctx context.Context, s1 models.Subscription) *RepositoryMockCreateSubscriptionExpectation {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSubscriptionExpectation{
		mock:   mmCreateSubscription.mock,
		params: &RepositoryMockCreateSubscriptionParams{ctx, s1},
	}
	mmCreateSubscription.expectations = append(mmCreateSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSubscriptionExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSubscriptionResults{i1, err}
	return e.mock
}

// CreateSubscription implements Repository
func (mmCreateSubscription *RepositoryMock) CreateSubscription(ctx context.Context, s1 models.Subscription) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscription.afterCreateSubscriptionCounter, 1)

	if mmCreateSubscription.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.inspectFuncCreateSubscription(ctx, s1)
	}

	mm_params := &RepositoryMockCreateSubscriptionParams{ctx, s1}

	// Record call args
	mmCreateSubscription.CreateSubscriptionMock.mutex.Lock()
	mmCreateSubscription.CreateSubscriptionMock.callArgs = append(mmCreateSubscription.CreateSubscriptionMock.callArgs, mm_params)
	mmCreateSubscription.CreateSubscriptionMock.mutex.Unlock()

	for _, e := range mmCreateSubscription.CreateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateSubscription.CreateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockCreateSubscriptionParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscription.t.Errorf("RepositoryMock.CreateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscription.t.Fatal("No results are set for the RepositoryMock.CreateSubscription")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateSubscription.funcCreateSubscription != nil {
		return mmCreateSubscription.funcCreateSubscription(ctx, s1)
	}
	mmCreateSubscription.t.Fatalf("Unexpected call to RepositoryMock.CreateSubscription. %v %v", ctx, s1)
	return
}

// CreateSubscriptionAfterCounter returns a count of finished RepositoryMock.CreateSubscription invocations
func (mmCreateSubscription *RepositoryMock) CreateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.afterCreateSubscriptionCounter)
}

// CreateSubscriptionBeforeCounter returns a count of RepositoryMock.CreateSubscription invocations
func (mmCreateSubscription *RepositoryMock) CreateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Calls() []*RepositoryMockCreateSubscriptionParams {
	mmCreateSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSubscriptionParams, len(mmCreateSubscription.callArgs))
	copy(argCopy, mmCreateSubscription.callArgs)

	mmCreateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriptionDone returns true if the count of the CreateSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSubscriptionDone() bool {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSubscriptionInspect() {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		if m.CreateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscription with params: %#v", *m.CreateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateSubscription")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx context.Context
	u1  models.User
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context, u1 models.User) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx, u1}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context, u1 models.User)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(i1 int, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{i1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context, u1 models.User) (i1 int, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context, u1 models.User) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx, u1},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context, u1 models.User) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, u1)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx, u1}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, u1)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v %v", ctx, u1)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

type mRepositoryMockDeleteSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSubscriberExpectation
	expectations       []*RepositoryMockDeleteSubscriberExpectation

	callArgs []*RepositoryMockDeleteSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteSubscriberExpectation specifies expectation struct of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteSubscriberParams
	results *RepositoryMockDeleteSubscriberResults
	Counter uint64
}

// RepositoryMockDeleteSubscriberParams contains parameters of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteSubscriberResults contains results of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &RepositoryMockDeleteSubscriberExpectation{}
	}

	mmDeleteSubscriber.defaultExpectation.params = &RepositoryMockDeleteSubscriberParams{ctx, i1}
	for _, e := range mmDeleteSubscriber.expectations {
		if minimock.Equal(e.params, mmDeleteSubscriber.defaultExpectation.params) {
			mmDeleteSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscriber.defaultExpectation.params)
		}
	}

	return mmDeleteSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSubscriber")
	}

	mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber = f

	return mmDeleteSubscriber
}

// Return sets up results that will be returned by Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Return(err error) *RepositoryMock {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &RepositoryMockDeleteSubscriberExpectation{mock: mmDeleteSubscriber.mock}
	}
	mmDeleteSubscriber.defaultExpectation.results = &RepositoryMockDeleteSubscriberResults{err}
	return mmDeleteSubscriber.mock
}

//Set uses given function f to mock the Repository.DeleteSubscriber method
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteSubscriber.defaultExpectation != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSubscriber method")
	}

	if len(mmDeleteSubscriber.expectations) > 0 {
		mmDeleteSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSubscriber method")
	}

	mmDeleteSubscriber.mock.funcDeleteSubscriber = f
	return mmDeleteSubscriber.mock
}

// When sets expectation for the Repository.DeleteSubscriber which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) When(ctx context.Context, i1 int) *RepositoryMockDeleteSubscriberExpectation {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSubscriberExpectation{
		mock:   mmDeleteSubscriber.mock,
		params: &RepositoryMockDeleteSubscriberParams{ctx, i1},
	}
	mmDeleteSubscriber.expectations = append(mmDeleteSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSubscriberExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSubscriberResults{err}
	return e.mock
}

// DeleteSubscriber implements Repository
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriber(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter, 1)

	if mmDeleteSubscriber.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.inspectFuncDeleteSubscriber(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteSubscriberParams{ctx, i1}

	// Record call args
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Lock()
	mmDeleteSubscriber.DeleteSubscriberMock.callArgs = append(mmDeleteSubscriber.DeleteSubscriberMock.callArgs, mm_params)
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Unlock()

	for _, e := range mmDeleteSubscriber.DeleteSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteSubscriberParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscriber.t.Errorf("RepositoryMock.DeleteSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscriber.t.Fatal("No results are set for the RepositoryMock.DeleteSubscriber")
		}
		return (*mm_results).err
	}
	if mmDeleteSubscriber.funcDeleteSubscriber != nil {
		return mmDeleteSubscriber.funcDeleteSubscriber(ctx, i1)
	}
	mmDeleteSubscriber.t.Fatalf("Unexpected call to RepositoryMock.DeleteSubscriber. %v %v", ctx, i1)
	return
}

// DeleteSubscriberAfterCounter returns a count of finished RepositoryMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter)
}

// DeleteSubscriberBeforeCounter returns a count of RepositoryMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Calls() []*RepositoryMockDeleteSubscriberParams {
	mmDeleteSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSubscriberParams, len(mmDeleteSubscriber.callArgs))
	copy(argCopy, mmDeleteSubscriber.callArgs)

	mmDeleteSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriberDone returns true if the count of the DeleteSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSubscriberDone() bool {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSubscriberInspect() {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		if m.DeleteSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscriber with params: %#v", *m.DeleteSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteSubscriber")
	}
}

type mRepositoryMockDeleteSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSubscriptionExpectation
	expectations       []*RepositoryMockDeleteSubscriptionExpectation

	callArgs []*RepositoryMockDeleteSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteSubscriptionExpectation specifies expectation struct of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteSubscriptionParams
	results *RepositoryMockDeleteSubscriptionResults
	Counter uint64
}

// RepositoryMockDeleteSubscriptionParams contains parameters of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteSubscriptionResults contains results of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &RepositoryMockDeleteSubscriptionExpectation{}
	}

	mmDeleteSubscription.defaultExpectation.params = &RepositoryMockDeleteSubscriptionParams{ctx, i1}
	for _, e := range mmDeleteSubscription.expectations {
		if minimock.Equal(e.params, mmDeleteSubscription.defaultExpectation.params) {
			mmDeleteSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscription.defaultExpectation.params)
		}
	}

	return mmDeleteSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteSubscription {
	if mmDeleteSubscription.mock.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSubscription")
	}

	mmDeleteSubscription.mock.inspectFuncDeleteSubscription = f

	return mmDeleteSubscription
}

// Return sets up results that will be returned by Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Return(err error) *RepositoryMock {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &RepositoryMockDeleteSubscriptionExpectation{mock: mmDeleteSubscription.mock}
	}
	mmDeleteSubscription.defaultExpectation.results = &RepositoryMockDeleteSubscriptionResults{err}
	return mmDeleteSubscription.mock
}

//Set uses given function f to mock the Repository.DeleteSubscription method
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteSubscription.defaultExpectation != nil {
		mmDeleteSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSubscription method")
	}

	if len(mmDeleteSubscription.expectations) > 0 {
		mmDeleteSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSubscription method")
	}

	mmDeleteSubscription.mock.funcDeleteSubscription = f
	return mmDeleteSubscription.mock
}

// When sets expectation for the Repository.DeleteSubscription which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) When(ctx context.Context, i1 int) *RepositoryMockDeleteSubscriptionExpectation {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSubscriptionExpectation{
		mock:   mmDeleteSubscription.mock,
		params: &RepositoryMockDeleteSubscriptionParams{ctx, i1},
	}
	mmDeleteSubscription.expectations = append(mmDeleteSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSubscriptionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSubscriptionResults{err}
	return e.mock
}

// DeleteSubscription implements Repository
func (mmDeleteSubscription *RepositoryMock) DeleteSubscription(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter, 1)

	if mmDeleteSubscription.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.inspectFuncDeleteSubscription(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteSubscriptionParams{ctx, i1}

	// Record call args
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Lock()
	mmDeleteSubscription.DeleteSubscriptionMock.callArgs = append(mmDeleteSubscription.DeleteSubscriptionMock.callArgs, mm_params)
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Unlock()

	for _, e := range mmDeleteSubscription.DeleteSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteSubscriptionParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscription.t.Errorf("RepositoryMock.DeleteSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscription.t.Fatal("No results are set for the RepositoryMock.DeleteSubscription")
		}
		return (*mm_results).err
	}
	if mmDeleteSubscription.funcDeleteSubscription != nil {
		return mmDeleteSubscription.funcDeleteSubscription(ctx, i1)
	}
	mmDeleteSubscription.t.Fatalf("Unexpected call to RepositoryMock.DeleteSubscription. %v %v", ctx, i1)
	return
}

// DeleteSubscriptionAfterCounter returns a count of finished RepositoryMock.DeleteSubscription invocations
func (mmDeleteSubscription *RepositoryMock) DeleteSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter)
}

// DeleteSubscriptionBeforeCounter returns a count of RepositoryMock.DeleteSubscription invocations
func (mmDeleteSubscription *RepositoryMock) DeleteSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Calls() []*RepositoryMockDeleteSubscriptionParams {
	mmDeleteSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSubscriptionParams, len(mmDeleteSubscription.callArgs))
	copy(argCopy, mmDeleteSubscription.callArgs)

	mmDeleteSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriptionDone returns true if the count of the DeleteSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSubscriptionDone() bool {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSubscriptionInspect() {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		if m.DeleteSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscription with params: %#v", *m.DeleteSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteSubscription")
	}
}

type mRepositoryMockDeleteUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserExpectation
	expectations       []*RepositoryMockDeleteUserExpectation

	callArgs []*RepositoryMockDeleteUserParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteUserExpectation specifies expectation struct of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteUserParams
	results *RepositoryMockDeleteUserResults
	Counter uint64
}

// RepositoryMockDeleteUserParams contains parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteUserResults contains results of the Repository.DeleteUser
type RepositoryMockDeleteUserResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	mmDeleteUser.defaultExpectation.params = &RepositoryMockDeleteUserParams{ctx, i1}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Return(err error) *RepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &RepositoryMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

//Set uses given function f to mock the Repository.DeleteUser method
func (mmDeleteUser *mRepositoryMockDeleteUser) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the Repository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mRepositoryMockDeleteUser) When(ctx context.Context, i1 int) *RepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &RepositoryMockDeleteUserParams{ctx, i1},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserResults{err}
	return e.mock
}

// DeleteUser implements Repository
func (mmDeleteUser *RepositoryMock) DeleteUser(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteUserParams{ctx, i1}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteUserParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the RepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, i1)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to RepositoryMock.DeleteUser. %v %v", ctx, i1)
	return
}

// DeleteUserAfterCounter returns a count of finished RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mRepositoryMockDeleteUser) Calls() []*RepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserDone() bool {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteUser")
	}
}

type mRepositoryMockGetSubscribers struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSubscribersExpectation
	expectations       []*RepositoryMockGetSubscribersExpectation

	callArgs []*RepositoryMockGetSubscribersParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSubscribersExpectation specifies expectation struct of the Repository.GetSubscribers
type RepositoryMockGetSubscribersExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSubscribersParams
	results *RepositoryMockGetSubscribersResults
	Counter uint64
}

// RepositoryMockGetSubscribersParams contains parameters of the Repository.GetSubscribers
type RepositoryMockGetSubscribersParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetSubscribersResults contains results of the Repository.GetSubscribers
type RepositoryMockGetSubscribersResults struct {
	sa1 []models.Subscriber
	err error
}

// Expect sets up expected params for Repository.GetSubscribers
func (mmGetSubscribers *mRepositoryMockGetSubscribers) Expect(ctx context.Context, i1 int) *mRepositoryMockGetSubscribers {
	if mmGetSubscribers.mock.funcGetSubscribers != nil {
		mmGetSubscribers.mock.t.Fatalf("RepositoryMock.GetSubscribers mock is already set by Set")
	}

	if mmGetSubscribers.defaultExpectation == nil {
		mmGetSubscribers.defaultExpectation = &RepositoryMockGetSubscribersExpectation{}
	}

	mmGetSubscribers.defaultExpectation.params = &RepositoryMockGetSubscribersParams{ctx, i1}
	for _, e := range mmGetSubscribers.expectations {
		if minimock.Equal(e.params, mmGetSubscribers.defaultExpectation.params) {
			mmGetSubscribers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscribers.defaultExpectation.params)
		}
	}

	return mmGetSubscribers
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSubscribers
func (mmGetSubscribers *mRepositoryMockGetSubscribers) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetSubscribers {
	if mmGetSubscribers.mock.inspectFuncGetSubscribers != nil {
		mmGetSubscribers.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSubscribers")
	}

	mmGetSubscribers.mock.inspectFuncGetSubscribers = f

	return mmGetSubscribers
}

// Return sets up results that will be returned by Repository.GetSubscribers
func (mmGetSubscribers *mRepositoryMockGetSubscribers) Return(sa1 []models.Subscriber, err error) *RepositoryMock {
	if mmGetSubscribers.mock.funcGetSubscribers != nil {
		mmGetSubscribers.mock.t.Fatalf("RepositoryMock.GetSubscribers mock is already set by Set")
	}

	if mmGetSubscribers.defaultExpectation == nil {
		mmGetSubscribers.defaultExpectation = &RepositoryMockGetSubscribersExpectation{mock: mmGetSubscribers.mock}
	}
	mmGetSubscribers.defaultExpectation.results = &RepositoryMockGetSubscribersResults{sa1, err}
	return mmGetSubscribers.mock
}

//Set uses given function f to mock the Repository.GetSubscribers method
func (mmGetSubscribers *mRepositoryMockGetSubscribers) Set(f func(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error)) *RepositoryMock {
	if mmGetSubscribers.defaultExpectation != nil {
		mmGetSubscribers.mock.t.Fatalf("Default expectation is already set for the Repository.GetSubscribers method")
	}

	if len(mmGetSubscribers.expectations) > 0 {
		mmGetSubscribers.mock.t.Fatalf("Some expectations are already set for the Repository.GetSubscribers method")
	}

	mmGetSubscribers.mock.funcGetSubscribers = f
	return mmGetSubscribers.mock
}

// When sets expectation for the Repository.GetSubscribers which will trigger the result defined by the following
// Then helper
func (mmGetSubscribers *mRepositoryMockGetSubscribers) When(ctx context.Context, i1 int) *RepositoryMockGetSubscribersExpectation {
	if mmGetSubscribers.mock.funcGetSubscribers != nil {
		mmGetSubscribers.mock.t.Fatalf("RepositoryMock.GetSubscribers mock is already set by Set")
	}

	expectation := &RepositoryMockGetSubscribersExpectation{
		mock:   mmGetSubscribers.mock,
		params: &RepositoryMockGetSubscribersParams{ctx, i1},
	}
	mmGetSubscribers.expectations = append(mmGetSubscribers.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSubscribers return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSubscribersExpectation) Then(sa1 []models.Subscriber, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSubscribersResults{sa1, err}
	return e.mock
}

// GetSubscribers implements Repository
func (mmGetSubscribers *RepositoryMock) GetSubscribers(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error) {
	mm_atomic.AddUint64(&mmGetSubscribers.beforeGetSubscribersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscribers.afterGetSubscribersCounter, 1)

	if mmGetSubscribers.inspectFuncGetSubscribers != nil {
		mmGetSubscribers.inspectFuncGetSubscribers(ctx, i1)
	}

	mm_params := &RepositoryMockGetSubscribersParams{ctx, i1}

	// Record call args
	mmGetSubscribers.GetSubscribersMock.mutex.Lock()
	mmGetSubscribers.GetSubscribersMock.callArgs = append(mmGetSubscribers.GetSubscribersMock.callArgs, mm_params)
	mmGetSubscribers.GetSubscribersMock.mutex.Unlock()

	for _, e := range mmGetSubscribers.GetSubscribersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSubscribers.GetSubscribersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscribers.GetSubscribersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscribers.GetSubscribersMock.defaultExpectation.params
		mm_got := RepositoryMockGetSubscribersParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscribers.t.Errorf("RepositoryMock.GetSubscribers got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscribers.GetSubscribersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscribers.t.Fatal("No results are set for the RepositoryMock.GetSubscribers")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSubscribers.funcGetSubscribers != nil {
		return mmGetSubscribers.funcGetSubscribers(ctx, i1)
	}
	mmGetSubscribers.t.Fatalf("Unexpected call to RepositoryMock.GetSubscribers. %v %v", ctx, i1)
	return
}

// GetSubscribersAfterCounter returns a count of finished RepositoryMock.GetSubscribers invocations
func (mmGetSubscribers *RepositoryMock) GetSubscribersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribers.afterGetSubscribersCounter)
}

// GetSubscribersBeforeCounter returns a count of RepositoryMock.GetSubscribers invocations
func (mmGetSubscribers *RepositoryMock) GetSubscribersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribers.beforeGetSubscribersCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSubscribers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscribers *mRepositoryMockGetSubscribers) Calls() []*RepositoryMockGetSubscribersParams {
	mmGetSubscribers.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSubscribersParams, len(mmGetSubscribers.callArgs))
	copy(argCopy, mmGetSubscribers.callArgs)

	mmGetSubscribers.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscribersDone returns true if the count of the GetSubscribers invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSubscribersDone() bool {
	for _, e := range m.GetSubscribersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribers != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscribersInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSubscribersInspect() {
	for _, e := range m.GetSubscribersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscribers with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersCounter) < 1 {
		if m.GetSubscribersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSubscribers")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscribers with params: %#v", *m.GetSubscribersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribers != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSubscribers")
	}
}

type mRepositoryMockGetSubscriptions struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSubscriptionsExpectation
	expectations       []*RepositoryMockGetSubscriptionsExpectation

	callArgs []*RepositoryMockGetSubscriptionsParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSubscriptionsExpectation specifies expectation struct of the Repository.GetSubscriptions
type RepositoryMockGetSubscriptionsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSubscriptionsParams
	results *RepositoryMockGetSubscriptionsResults
	Counter uint64
}

// RepositoryMockGetSubscriptionsParams contains parameters of the Repository.GetSubscriptions
type RepositoryMockGetSubscriptionsParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetSubscriptionsResults contains results of the Repository.GetSubscriptions
type RepositoryMockGetSubscriptionsResults struct {
	sa1 []models.Subscription
	err error
}

// Expect sets up expected params for Repository.GetSubscriptions
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) Expect(ctx context.Context, i1 int) *mRepositoryMockGetSubscriptions {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("RepositoryMock.GetSubscriptions mock is already set by Set")
	}

	if mmGetSubscriptions.defaultExpectation == nil {
		mmGetSubscriptions.defaultExpectation = &RepositoryMockGetSubscriptionsExpectation{}
	}

	mmGetSubscriptions.defaultExpectation.params = &RepositoryMockGetSubscriptionsParams{ctx, i1}
	for _, e := range mmGetSubscriptions.expectations {
		if minimock.Equal(e.params, mmGetSubscriptions.defaultExpectation.params) {
			mmGetSubscriptions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscriptions.defaultExpectation.params)
		}
	}

	return mmGetSubscriptions
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSubscriptions
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetSubscriptions {
	if mmGetSubscriptions.mock.inspectFuncGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSubscriptions")
	}

	mmGetSubscriptions.mock.inspectFuncGetSubscriptions = f

	return mmGetSubscriptions
}

// Return sets up results that will be returned by Repository.GetSubscriptions
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) Return(sa1 []models.Subscription, err error) *RepositoryMock {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("RepositoryMock.GetSubscriptions mock is already set by Set")
	}

	if mmGetSubscriptions.defaultExpectation == nil {
		mmGetSubscriptions.defaultExpectation = &RepositoryMockGetSubscriptionsExpectation{mock: mmGetSubscriptions.mock}
	}
	mmGetSubscriptions.defaultExpectation.results = &RepositoryMockGetSubscriptionsResults{sa1, err}
	return mmGetSubscriptions.mock
}

//Set uses given function f to mock the Repository.GetSubscriptions method
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) Set(f func(ctx context.Context, i1 int) (sa1 []models.Subscription, err error)) *RepositoryMock {
	if mmGetSubscriptions.defaultExpectation != nil {
		mmGetSubscriptions.mock.t.Fatalf("Default expectation is already set for the Repository.GetSubscriptions method")
	}

	if len(mmGetSubscriptions.expectations) > 0 {
		mmGetSubscriptions.mock.t.Fatalf("Some expectations are already set for the Repository.GetSubscriptions method")
	}

	mmGetSubscriptions.mock.funcGetSubscriptions = f
	return mmGetSubscriptions.mock
}

// When sets expectation for the Repository.GetSubscriptions which will trigger the result defined by the following
// Then helper
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) When(ctx context.Context, i1 int) *RepositoryMockGetSubscriptionsExpectation {
	if mmGetSubscriptions.mock.funcGetSubscriptions != nil {
		mmGetSubscriptions.mock.t.Fatalf("RepositoryMock.GetSubscriptions mock is already set by Set")
	}

	expectation := &RepositoryMockGetSubscriptionsExpectation{
		mock:   mmGetSubscriptions.mock,
		params: &RepositoryMockGetSubscriptionsParams{ctx, i1},
	}
	mmGetSubscriptions.expectations = append(mmGetSubscriptions.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSubscriptions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSubscriptionsExpectation) Then(sa1 []models.Subscription, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSubscriptionsResults{sa1, err}
	return e.mock
}

// GetSubscriptions implements Repository
func (mmGetSubscriptions *RepositoryMock) GetSubscriptions(ctx context.Context, i1 int) (sa1 []models.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetSubscriptions.beforeGetSubscriptionsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscriptions.afterGetSubscriptionsCounter, 1)

	if mmGetSubscriptions.inspectFuncGetSubscriptions != nil {
		mmGetSubscriptions.inspectFuncGetSubscriptions(ctx, i1)
	}

	mm_params := &RepositoryMockGetSubscriptionsParams{ctx, i1}

	// Record call args
	mmGetSubscriptions.GetSubscriptionsMock.mutex.Lock()
	mmGetSubscriptions.GetSubscriptionsMock.callArgs = append(mmGetSubscriptions.GetSubscriptionsMock.callArgs, mm_params)
	mmGetSubscriptions.GetSubscriptionsMock.mutex.Unlock()

	for _, e := range mmGetSubscriptions.GetSubscriptionsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.params
		mm_got := RepositoryMockGetSubscriptionsParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscriptions.t.Errorf("RepositoryMock.GetSubscriptions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscriptions.GetSubscriptionsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscriptions.t.Fatal("No results are set for the RepositoryMock.GetSubscriptions")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSubscriptions.funcGetSubscriptions != nil {
		return mmGetSubscriptions.funcGetSubscriptions(ctx, i1)
	}
	mmGetSubscriptions.t.Fatalf("Unexpected call to RepositoryMock.GetSubscriptions. %v %v", ctx, i1)
	return
}

// GetSubscriptionsAfterCounter returns a count of finished RepositoryMock.GetSubscriptions invocations
func (mmGetSubscriptions *RepositoryMock) GetSubscriptionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptions.afterGetSubscriptionsCounter)
}

// GetSubscriptionsBeforeCounter returns a count of RepositoryMock.GetSubscriptions invocations
func (mmGetSubscriptions *RepositoryMock) GetSubscriptionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptions.beforeGetSubscriptionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSubscriptions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscriptions *mRepositoryMockGetSubscriptions) Calls() []*RepositoryMockGetSubscriptionsParams {
	mmGetSubscriptions.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSubscriptionsParams, len(mmGetSubscriptions.callArgs))
	copy(argCopy, mmGetSubscriptions.callArgs)

	mmGetSubscriptions.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionsDone returns true if the count of the GetSubscriptions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSubscriptionsDone() bool {
	for _, e := range m.GetSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptions != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSubscriptionsInspect() {
	for _, e := range m.GetSubscriptionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscriptions with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		if m.GetSubscriptionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSubscriptions")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscriptions with params: %#v", *m.GetSubscriptionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptions != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSubscriptions")
	}
}

type mRepositoryMockReadSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadSubscriberExpectation
	expectations       []*RepositoryMockReadSubscriberExpectation

	callArgs []*RepositoryMockReadSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockReadSubscriberExpectation specifies expectation struct of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadSubscriberParams
	results *RepositoryMockReadSubscriberResults
	Counter uint64
}

// RepositoryMockReadSubscriberParams contains parameters of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadSubscriberResults contains results of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberResults struct {
	s1  models.Subscriber
	err error
}

// Expect sets up expected params for Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Expect(ctx context.Context, i1 int) *mRepositoryMockReadSubscriber {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &RepositoryMockReadSubscriberExpectation{}
	}

	mmReadSubscriber.defaultExpectation.params = &RepositoryMockReadSubscriberParams{ctx, i1}
	for _, e := range mmReadSubscriber.expectations {
		if minimock.Equal(e.params, mmReadSubscriber.defaultExpectation.params) {
			mmReadSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscriber.defaultExpectation.params)
		}
	}

	return mmReadSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadSubscriber {
	if mmReadSubscriber.mock.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadSubscriber")
	}

	mmReadSubscriber.mock.inspectFuncReadSubscriber = f

	return mmReadSubscriber
}

// Return sets up results that will be returned by Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Return(s1 models.Subscriber, err error) *RepositoryMock {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &RepositoryMockReadSubscriberExpectation{mock: mmReadSubscriber.mock}
	}
	mmReadSubscriber.defaultExpectation.results = &RepositoryMockReadSubscriberResults{s1, err}
	return mmReadSubscriber.mock
}

//Set uses given function f to mock the Repository.ReadSubscriber method
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Set(f func(ctx context.Context, i1 int) (s1 models.Subscriber, err error)) *RepositoryMock {
	if mmReadSubscriber.defaultExpectation != nil {
		mmReadSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.ReadSubscriber method")
	}

	if len(mmReadSubscriber.expectations) > 0 {
		mmReadSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.ReadSubscriber method")
	}

	mmReadSubscriber.mock.funcReadSubscriber = f
	return mmReadSubscriber.mock
}

// When sets expectation for the Repository.ReadSubscriber which will trigger the result defined by the following
// Then helper
func (mmReadSubscriber *mRepositoryMockReadSubscriber) When(ctx context.Context, i1 int) *RepositoryMockReadSubscriberExpectation {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockReadSubscriberExpectation{
		mock:   mmReadSubscriber.mock,
		params: &RepositoryMockReadSubscriberParams{ctx, i1},
	}
	mmReadSubscriber.expectations = append(mmReadSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadSubscriberExpectation) Then(s1 models.Subscriber, err error) *RepositoryMock {
	e.results = &RepositoryMockReadSubscriberResults{s1, err}
	return e.mock
}

// ReadSubscriber implements Repository
func (mmReadSubscriber *RepositoryMock) ReadSubscriber(ctx context.Context, i1 int) (s1 models.Subscriber, err error) {
	mm_atomic.AddUint64(&mmReadSubscriber.beforeReadSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscriber.afterReadSubscriberCounter, 1)

	if mmReadSubscriber.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.inspectFuncReadSubscriber(ctx, i1)
	}

	mm_params := &RepositoryMockReadSubscriberParams{ctx, i1}

	// Record call args
	mmReadSubscriber.ReadSubscriberMock.mutex.Lock()
	mmReadSubscriber.ReadSubscriberMock.callArgs = append(mmReadSubscriber.ReadSubscriberMock.callArgs, mm_params)
	mmReadSubscriber.ReadSubscriberMock.mutex.Unlock()

	for _, e := range mmReadSubscriber.ReadSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSubscriber.ReadSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscriber.ReadSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockReadSubscriberParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscriber.t.Errorf("RepositoryMock.ReadSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscriber.t.Fatal("No results are set for the RepositoryMock.ReadSubscriber")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmReadSubscriber.funcReadSubscriber != nil {
		return mmReadSubscriber.funcReadSubscriber(ctx, i1)
	}
	mmReadSubscriber.t.Fatalf("Unexpected call to RepositoryMock.ReadSubscriber. %v %v", ctx, i1)
	return
}

// ReadSubscriberAfterCounter returns a count of finished RepositoryMock.ReadSubscriber invocations
func (mmReadSubscriber *RepositoryMock) ReadSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.afterReadSubscriberCounter)
}

// ReadSubscriberBeforeCounter returns a count of RepositoryMock.ReadSubscriber invocations
func (mmReadSubscriber *RepositoryMock) ReadSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.beforeReadSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Calls() []*RepositoryMockReadSubscriberParams {
	mmReadSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockReadSubscriberParams, len(mmReadSubscriber.callArgs))
	copy(argCopy, mmReadSubscriber.callArgs)

	mmReadSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriberDone returns true if the count of the ReadSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadSubscriberDone() bool {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadSubscriberInspect() {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		if m.ReadSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscriber with params: %#v", *m.ReadSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadSubscriber")
	}
}

type mRepositoryMockReadSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadSubscriptionExpectation
	expectations       []*RepositoryMockReadSubscriptionExpectation

	callArgs []*RepositoryMockReadSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockReadSubscriptionExpectation specifies expectation struct of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadSubscriptionParams
	results *RepositoryMockReadSubscriptionResults
	Counter uint64
}

// RepositoryMockReadSubscriptionParams contains parameters of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadSubscriptionResults contains results of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionResults struct {
	s1  models.Subscription
	err error
}

// Expect sets up expected params for Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Expect(ctx context.Context, i1 int) *mRepositoryMockReadSubscription {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &RepositoryMockReadSubscriptionExpectation{}
	}

	mmReadSubscription.defaultExpectation.params = &RepositoryMockReadSubscriptionParams{ctx, i1}
	for _, e := range mmReadSubscription.expectations {
		if minimock.Equal(e.params, mmReadSubscription.defaultExpectation.params) {
			mmReadSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscription.defaultExpectation.params)
		}
	}

	return mmReadSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadSubscription {
	if mmReadSubscription.mock.inspectFuncReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadSubscription")
	}

	mmReadSubscription.mock.inspectFuncReadSubscription = f

	return mmReadSubscription
}

// Return sets up results that will be returned by Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Return(s1 models.Subscription, err error) *RepositoryMock {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &RepositoryMockReadSubscriptionExpectation{mock: mmReadSubscription.mock}
	}
	mmReadSubscription.defaultExpectation.results = &RepositoryMockReadSubscriptionResults{s1, err}
	return mmReadSubscription.mock
}

//Set uses given function f to mock the Repository.ReadSubscription method
func (mmReadSubscription *mRepositoryMockReadSubscription) Set(f func(ctx context.Context, i1 int) (s1 models.Subscription, err error)) *RepositoryMock {
	if mmReadSubscription.defaultExpectation != nil {
		mmReadSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.ReadSubscription method")
	}

	if len(mmReadSubscription.expectations) > 0 {
		mmReadSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.ReadSubscription method")
	}

	mmReadSubscription.mock.funcReadSubscription = f
	return mmReadSubscription.mock
}

// When sets expectation for the Repository.ReadSubscription which will trigger the result defined by the following
// Then helper
func (mmReadSubscription *mRepositoryMockReadSubscription) When(ctx context.Context, i1 int) *RepositoryMockReadSubscriptionExpectation {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockReadSubscriptionExpectation{
		mock:   mmReadSubscription.mock,
		params: &RepositoryMockReadSubscriptionParams{ctx, i1},
	}
	mmReadSubscription.expectations = append(mmReadSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadSubscriptionExpectation) Then(s1 models.Subscription, err error) *RepositoryMock {
	e.results = &RepositoryMockReadSubscriptionResults{s1, err}
	return e.mock
}

// ReadSubscription implements Repository
func (mmReadSubscription *RepositoryMock) ReadSubscription(ctx context.Context, i1 int) (s1 models.Subscription, err error) {
	mm_atomic.AddUint64(&mmReadSubscription.beforeReadSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscription.afterReadSubscriptionCounter, 1)

	if mmReadSubscription.inspectFuncReadSubscription != nil {
		mmReadSubscription.inspectFuncReadSubscription(ctx, i1)
	}

	mm_params := &RepositoryMockReadSubscriptionParams{ctx, i1}

	// Record call args
	mmReadSubscription.ReadSubscriptionMock.mutex.Lock()
	mmReadSubscription.ReadSubscriptionMock.callArgs = append(mmReadSubscription.ReadSubscriptionMock.callArgs, mm_params)
	mmReadSubscription.ReadSubscriptionMock.mutex.Unlock()

	for _, e := range mmReadSubscription.ReadSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSubscription.ReadSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscription.ReadSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockReadSubscriptionParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscription.t.Errorf("RepositoryMock.ReadSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscription.t.Fatal("No results are set for the RepositoryMock.ReadSubscription")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmReadSubscription.funcReadSubscription != nil {
		return mmReadSubscription.funcReadSubscription(ctx, i1)
	}
	mmReadSubscription.t.Fatalf("Unexpected call to RepositoryMock.ReadSubscription. %v %v", ctx, i1)
	return
}

// ReadSubscriptionAfterCounter returns a count of finished RepositoryMock.ReadSubscription invocations
func (mmReadSubscription *RepositoryMock) ReadSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.afterReadSubscriptionCounter)
}

// ReadSubscriptionBeforeCounter returns a count of RepositoryMock.ReadSubscription invocations
func (mmReadSubscription *RepositoryMock) ReadSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.beforeReadSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscription *mRepositoryMockReadSubscription) Calls() []*RepositoryMockReadSubscriptionParams {
	mmReadSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockReadSubscriptionParams, len(mmReadSubscription.callArgs))
	copy(argCopy, mmReadSubscription.callArgs)

	mmReadSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriptionDone returns true if the count of the ReadSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadSubscriptionDone() bool {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadSubscriptionInspect() {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		if m.ReadSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscription with params: %#v", *m.ReadSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadSubscription")
	}
}

type mRepositoryMockReadUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadUserExpectation
	expectations       []*RepositoryMockReadUserExpectation

	callArgs []*RepositoryMockReadUserParams
	mutex    sync.RWMutex
}

// RepositoryMockReadUserExpectation specifies expectation struct of the Repository.ReadUser
type RepositoryMockReadUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadUserParams
	results *RepositoryMockReadUserResults
	Counter uint64
}

// RepositoryMockReadUserParams contains parameters of the Repository.ReadUser
type RepositoryMockReadUserParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadUserResults contains results of the Repository.ReadUser
type RepositoryMockReadUserResults struct {
	u1  models.User
	err error
}

// Expect sets up expected params for Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Expect(ctx context.Context, i1 int) *mRepositoryMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &RepositoryMockReadUserExpectation{}
	}

	mmReadUser.defaultExpectation.params = &RepositoryMockReadUserParams{ctx, i1}
	for _, e := range mmReadUser.expectations {
		if minimock.Equal(e.params, mmReadUser.defaultExpectation.params) {
			mmReadUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadUser.defaultExpectation.params)
		}
	}

	return mmReadUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadUser {
	if mmReadUser.mock.inspectFuncReadUser != nil {
		mmReadUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadUser")
	}

	mmReadUser.mock.inspectFuncReadUser = f

	return mmReadUser
}

// Return sets up results that will be returned by Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Return(u1 models.User, err error) *RepositoryMock {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &RepositoryMockReadUserExpectation{mock: mmReadUser.mock}
	}
	mmReadUser.defaultExpectation.results = &RepositoryMockReadUserResults{u1, err}
	return mmReadUser.mock
}

//Set uses given function f to mock the Repository.ReadUser method
func (mmReadUser *mRepositoryMockReadUser) Set(f func(ctx context.Context, i1 int) (u1 models.User, err error)) *RepositoryMock {
	if mmReadUser.defaultExpectation != nil {
		mmReadUser.mock.t.Fatalf("Default expectation is already set for the Repository.ReadUser method")
	}

	if len(mmReadUser.expectations) > 0 {
		mmReadUser.mock.t.Fatalf("Some expectations are already set for the Repository.ReadUser method")
	}

	mmReadUser.mock.funcReadUser = f
	return mmReadUser.mock
}

// When sets expectation for the Repository.ReadUser which will trigger the result defined by the following
// Then helper
func (mmReadUser *mRepositoryMockReadUser) When(ctx context.Context, i1 int) *RepositoryMockReadUserExpectation {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	expectation := &RepositoryMockReadUserExpectation{
		mock:   mmReadUser.mock,
		params: &RepositoryMockReadUserParams{ctx, i1},
	}
	mmReadUser.expectations = append(mmReadUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadUserExpectation) Then(u1 models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockReadUserResults{u1, err}
	return e.mock
}

// ReadUser implements Repository
func (mmReadUser *RepositoryMock) ReadUser(ctx context.Context, i1 int) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmReadUser.beforeReadUserCounter, 1)
	defer mm_atomic.AddUint64(&mmReadUser.afterReadUserCounter, 1)

	if mmReadUser.inspectFuncReadUser != nil {
		mmReadUser.inspectFuncReadUser(ctx, i1)
	}

	mm_params := &RepositoryMockReadUserParams{ctx, i1}

	// Record call args
	mmReadUser.ReadUserMock.mutex.Lock()
	mmReadUser.ReadUserMock.callArgs = append(mmReadUser.ReadUserMock.callArgs, mm_params)
	mmReadUser.ReadUserMock.mutex.Unlock()

	for _, e := range mmReadUser.ReadUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmReadUser.ReadUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadUser.ReadUserMock.defaultExpectation.Counter, 1)
		mm_want := mmReadUser.ReadUserMock.defaultExpectation.params
		mm_got := RepositoryMockReadUserParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadUser.t.Errorf("RepositoryMock.ReadUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadUser.ReadUserMock.defaultExpectation.results
		if mm_results == nil {
			mmReadUser.t.Fatal("No results are set for the RepositoryMock.ReadUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmReadUser.funcReadUser != nil {
		return mmReadUser.funcReadUser(ctx, i1)
	}
	mmReadUser.t.Fatalf("Unexpected call to RepositoryMock.ReadUser. %v %v", ctx, i1)
	return
}

// ReadUserAfterCounter returns a count of finished RepositoryMock.ReadUser invocations
func (mmReadUser *RepositoryMock) ReadUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.afterReadUserCounter)
}

// ReadUserBeforeCounter returns a count of RepositoryMock.ReadUser invocations
func (mmReadUser *RepositoryMock) ReadUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.beforeReadUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadUser *mRepositoryMockReadUser) Calls() []*RepositoryMockReadUserParams {
	mmReadUser.mutex.RLock()

	argCopy := make([]*RepositoryMockReadUserParams, len(mmReadUser.callArgs))
	copy(argCopy, mmReadUser.callArgs)

	mmReadUser.mutex.RUnlock()

	return argCopy
}

// MinimockReadUserDone returns true if the count of the ReadUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadUserDone() bool {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadUserInspect() {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		if m.ReadUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadUser with params: %#v", *m.ReadUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadUser")
	}
}

type mRepositoryMockUpdateSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSubscriberExpectation
	expectations       []*RepositoryMockUpdateSubscriberExpectation

	callArgs []*RepositoryMockUpdateSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateSubscriberExpectation specifies expectation struct of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateSubscriberParams
	results *RepositoryMockUpdateSubscriberResults
	Counter uint64
}

// RepositoryMockUpdateSubscriberParams contains parameters of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberParams struct {
	ctx context.Context
	s1  models.Subscriber
}

// RepositoryMockUpdateSubscriberResults contains results of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Expect(ctx context.Context, s1 models.Subscriber) *mRepositoryMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &RepositoryMockUpdateSubscriberExpectation{}
	}

	mmUpdateSubscriber.defaultExpectation.params = &RepositoryMockUpdateSubscriberParams{ctx, s1}
	for _, e := range mmUpdateSubscriber.expectations {
		if minimock.Equal(e.params, mmUpdateSubscriber.defaultExpectation.params) {
			mmUpdateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscriber.defaultExpectation.params)
		}
	}

	return mmUpdateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Inspect(f func(ctx context.Context, s1 models.Subscriber)) *mRepositoryMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSubscriber")
	}

	mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber = f

	return mmUpdateSubscriber
}

// Return sets up results that will be returned by Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Return(err error) *RepositoryMock {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &RepositoryMockUpdateSubscriberExpectation{mock: mmUpdateSubscriber.mock}
	}
	mmUpdateSubscriber.defaultExpectation.results = &RepositoryMockUpdateSubscriberResults{err}
	return mmUpdateSubscriber.mock
}

//Set uses given function f to mock the Repository.UpdateSubscriber method
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Set(f func(ctx context.Context, s1 models.Subscriber) (err error)) *RepositoryMock {
	if mmUpdateSubscriber.defaultExpectation != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSubscriber method")
	}

	if len(mmUpdateSubscriber.expectations) > 0 {
		mmUpdateSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSubscriber method")
	}

	mmUpdateSubscriber.mock.funcUpdateSubscriber = f
	return mmUpdateSubscriber.mock
}

// When sets expectation for the Repository.UpdateSubscriber which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) When(ctx context.Context, s1 models.Subscriber) *RepositoryMockUpdateSubscriberExpectation {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSubscriberExpectation{
		mock:   mmUpdateSubscriber.mock,
		params: &RepositoryMockUpdateSubscriberParams{ctx, s1},
	}
	mmUpdateSubscriber.expectations = append(mmUpdateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSubscriberExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSubscriberResults{err}
	return e.mock
}

// UpdateSubscriber implements Repository
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriber(ctx context.Context, s1 models.Subscriber) (err error) {
	mm_atomic.AddUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter, 1)

	if mmUpdateSubscriber.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.inspectFuncUpdateSubscriber(ctx, s1)
	}

	mm_params := &RepositoryMockUpdateSubscriberParams{ctx, s1}

	// Record call args
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Lock()
	mmUpdateSubscriber.UpdateSubscriberMock.callArgs = append(mmUpdateSubscriber.UpdateSubscriberMock.callArgs, mm_params)
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Unlock()

	for _, e := range mmUpdateSubscriber.UpdateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateSubscriberParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscriber.t.Errorf("RepositoryMock.UpdateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscriber.t.Fatal("No results are set for the RepositoryMock.UpdateSubscriber")
		}
		return (*mm_results).err
	}
	if mmUpdateSubscriber.funcUpdateSubscriber != nil {
		return mmUpdateSubscriber.funcUpdateSubscriber(ctx, s1)
	}
	mmUpdateSubscriber.t.Fatalf("Unexpected call to RepositoryMock.UpdateSubscriber. %v %v", ctx, s1)
	return
}

// UpdateSubscriberAfterCounter returns a count of finished RepositoryMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter)
}

// UpdateSubscriberBeforeCounter returns a count of RepositoryMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Calls() []*RepositoryMockUpdateSubscriberParams {
	mmUpdateSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSubscriberParams, len(mmUpdateSubscriber.callArgs))
	copy(argCopy, mmUpdateSubscriber.callArgs)

	mmUpdateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriberDone returns true if the count of the UpdateSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSubscriberDone() bool {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSubscriberInspect() {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		if m.UpdateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscriber with params: %#v", *m.UpdateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateSubscriber")
	}
}

type mRepositoryMockUpdateSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSubscriptionExpectation
	expectations       []*RepositoryMockUpdateSubscriptionExpectation

	callArgs []*RepositoryMockUpdateSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateSubscriptionExpectation specifies expectation struct of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateSubscriptionParams
	results *RepositoryMockUpdateSubscriptionResults
	Counter uint64
}

// RepositoryMockUpdateSubscriptionParams contains parameters of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionParams struct {
	ctx context.Context
	s1  models.Subscription
}

// RepositoryMockUpdateSubscriptionResults contains results of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Expect(ctx context.Context, s1 models.Subscription) *mRepositoryMockUpdateSubscription {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &RepositoryMockUpdateSubscriptionExpectation{}
	}

	mmUpdateSubscription.defaultExpectation.params = &RepositoryMockUpdateSubscriptionParams{ctx, s1}
	for _, e := range mmUpdateSubscription.expectations {
		if minimock.Equal(e.params, mmUpdateSubscription.defaultExpectation.params) {
			mmUpdateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscription.defaultExpectation.params)
		}
	}

	return mmUpdateSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Inspect(f func(ctx context.Context, s1 models.Subscription)) *mRepositoryMockUpdateSubscription {
	if mmUpdateSubscription.mock.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSubscription")
	}

	mmUpdateSubscription.mock.inspectFuncUpdateSubscription = f

	return mmUpdateSubscription
}

// Return sets up results that will be returned by Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Return(err error) *RepositoryMock {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &RepositoryMockUpdateSubscriptionExpectation{mock: mmUpdateSubscription.mock}
	}
	mmUpdateSubscription.defaultExpectation.results = &RepositoryMockUpdateSubscriptionResults{err}
	return mmUpdateSubscription.mock
}

//Set uses given function f to mock the Repository.UpdateSubscription method
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Set(f func(ctx context.Context, s1 models.Subscription) (err error)) *RepositoryMock {
	if mmUpdateSubscription.defaultExpectation != nil {
		mmUpdateSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSubscription method")
	}

	if len(mmUpdateSubscription.expectations) > 0 {
		mmUpdateSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSubscription method")
	}

	mmUpdateSubscription.mock.funcUpdateSubscription = f
	return mmUpdateSubscription.mock
}

// When sets expectation for the Repository.UpdateSubscription which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) When(ctx context.Context, s1 models.Subscription) *RepositoryMockUpdateSubscriptionExpectation {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSubscriptionExpectation{
		mock:   mmUpdateSubscription.mock,
		params: &RepositoryMockUpdateSubscriptionParams{ctx, s1},
	}
	mmUpdateSubscription.expectations = append(mmUpdateSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSubscriptionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSubscriptionResults{err}
	return e.mock
}

// UpdateSubscription implements Repository
func (mmUpdateSubscription *RepositoryMock) UpdateSubscription(ctx context.Context, s1 models.Subscription) (err error) {
	mm_atomic.AddUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter, 1)

	if mmUpdateSubscription.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.inspectFuncUpdateSubscription(ctx, s1)
	}

	mm_params := &RepositoryMockUpdateSubscriptionParams{ctx, s1}

	// Record call args
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Lock()
	mmUpdateSubscription.UpdateSubscriptionMock.callArgs = append(mmUpdateSubscription.UpdateSubscriptionMock.callArgs, mm_params)
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Unlock()

	for _, e := range mmUpdateSubscription.UpdateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateSubscriptionParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscription.t.Errorf("RepositoryMock.UpdateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscription.t.Fatal("No results are set for the RepositoryMock.UpdateSubscription")
		}
		return (*mm_results).err
	}
	if mmUpdateSubscription.funcUpdateSubscription != nil {
		return mmUpdateSubscription.funcUpdateSubscription(ctx, s1)
	}
	mmUpdateSubscription.t.Fatalf("Unexpected call to RepositoryMock.UpdateSubscription. %v %v", ctx, s1)
	return
}

// UpdateSubscriptionAfterCounter returns a count of finished RepositoryMock.UpdateSubscription invocations
func (mmUpdateSubscription *RepositoryMock) UpdateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter)
}

// UpdateSubscriptionBeforeCounter returns a count of RepositoryMock.UpdateSubscription invocations
func (mmUpdateSubscription *RepositoryMock) UpdateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Calls() []*RepositoryMockUpdateSubscriptionParams {
	mmUpdateSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSubscriptionParams, len(mmUpdateSubscription.callArgs))
	copy(argCopy, mmUpdateSubscription.callArgs)

	mmUpdateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriptionDone returns true if the count of the UpdateSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSubscriptionDone() bool {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSubscriptionInspect() {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		if m.UpdateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscription with params: %#v", *m.UpdateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateSubscription")
	}
}

type mRepositoryMockUpdateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserExpectation
	expectations       []*RepositoryMockUpdateUserExpectation

	callArgs []*RepositoryMockUpdateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateUserExpectation specifies expectation struct of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateUserParams
	results *RepositoryMockUpdateUserResults
	Counter uint64
}

// RepositoryMockUpdateUserParams contains parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParams struct {
	ctx context.Context
	u1  models.User
}

// RepositoryMockUpdateUserResults contains results of the Repository.UpdateUser
type RepositoryMockUpdateUserResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Expect(ctx context.Context, u1 models.User) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	mmUpdateUser.defaultExpectation.params = &RepositoryMockUpdateUserParams{ctx, u1}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, u1 models.User)) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Return(err error) *RepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &RepositoryMockUpdateUserResults{err}
	return mmUpdateUser.mock
}

//Set uses given function f to mock the Repository.UpdateUser method
func (mmUpdateUser *mRepositoryMockUpdateUser) Set(f func(ctx context.Context, u1 models.User) (err error)) *RepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the Repository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mRepositoryMockUpdateUser) When(ctx context.Context, u1 models.User) *RepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &RepositoryMockUpdateUserParams{ctx, u1},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserResults{err}
	return e.mock
}

// UpdateUser implements Repository
func (mmUpdateUser *RepositoryMock) UpdateUser(ctx context.Context, u1 models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, u1)
	}

	mm_params := &RepositoryMockUpdateUserParams{ctx, u1}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateUserParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the RepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, u1)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to RepositoryMock.UpdateUser. %v %v", ctx, u1)
	return
}

// UpdateUserAfterCounter returns a count of finished RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mRepositoryMockUpdateUser) Calls() []*RepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserDone() bool {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSubscriberInspect()

		m.MinimockCreateSubscriptionInspect()

		m.MinimockCreateUserInspect()

		m.MinimockDeleteSubscriberInspect()

		m.MinimockDeleteSubscriptionInspect()

		m.MinimockDeleteUserInspect()

		m.MinimockGetSubscribersInspect()

		m.MinimockGetSubscriptionsInspect()

		m.MinimockReadSubscriberInspect()

		m.MinimockReadSubscriptionInspect()

		m.MinimockReadUserInspect()

		m.MinimockUpdateSubscriberInspect()

		m.MinimockUpdateSubscriptionInspect()

		m.MinimockUpdateUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSubscriberDone() &&
		m.MinimockCreateSubscriptionDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteSubscriberDone() &&
		m.MinimockDeleteSubscriptionDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetSubscribersDone() &&
		m.MinimockGetSubscriptionsDone() &&
		m.MinimockReadSubscriberDone() &&
		m.MinimockReadSubscriptionDone() &&
		m.MinimockReadUserDone() &&
		m.MinimockUpdateSubscriberDone() &&
		m.MinimockUpdateSubscriptionDone() &&
		m.MinimockUpdateUserDone()
}
