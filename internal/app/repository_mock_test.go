package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/inqast/fsmanager/internal/app.Repository -o ./repository_mock_test.go -n RepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/inqast/fsmanager/internal/models"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateSubscriber          func(ctx context.Context, s1 models.Subscriber) (i1 int, err error)
	inspectFuncCreateSubscriber   func(ctx context.Context, s1 models.Subscriber)
	afterCreateSubscriberCounter  uint64
	beforeCreateSubscriberCounter uint64
	CreateSubscriberMock          mRepositoryMockCreateSubscriber

	funcCreateSubscription          func(ctx context.Context, s1 models.Subscription) (i1 int, err error)
	inspectFuncCreateSubscription   func(ctx context.Context, s1 models.Subscription)
	afterCreateSubscriptionCounter  uint64
	beforeCreateSubscriptionCounter uint64
	CreateSubscriptionMock          mRepositoryMockCreateSubscription

	funcCreateUser          func(ctx context.Context, u1 models.User) (i1 int, err error)
	inspectFuncCreateUser   func(ctx context.Context, u1 models.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcDeleteSubscriber          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteSubscriber   func(ctx context.Context, i1 int)
	afterDeleteSubscriberCounter  uint64
	beforeDeleteSubscriberCounter uint64
	DeleteSubscriberMock          mRepositoryMockDeleteSubscriber

	funcDeleteSubscription          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteSubscription   func(ctx context.Context, i1 int)
	afterDeleteSubscriptionCounter  uint64
	beforeDeleteSubscriptionCounter uint64
	DeleteSubscriptionMock          mRepositoryMockDeleteSubscription

	funcDeleteUser          func(ctx context.Context, i1 int) (err error)
	inspectFuncDeleteUser   func(ctx context.Context, i1 int)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mRepositoryMockDeleteUser

	funcGetSubscribersForSubscription          func(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error)
	inspectFuncGetSubscribersForSubscription   func(ctx context.Context, i1 int)
	afterGetSubscribersForSubscriptionCounter  uint64
	beforeGetSubscribersForSubscriptionCounter uint64
	GetSubscribersForSubscriptionMock          mRepositoryMockGetSubscribersForSubscription

	funcGetSubscriptionsForUser          func(ctx context.Context, i1 int) (sa1 []models.Subscription, err error)
	inspectFuncGetSubscriptionsForUser   func(ctx context.Context, i1 int)
	afterGetSubscriptionsForUserCounter  uint64
	beforeGetSubscriptionsForUserCounter uint64
	GetSubscriptionsForUserMock          mRepositoryMockGetSubscriptionsForUser

	funcGetUserByTelegramID          func(ctx context.Context, i1 int) (u1 models.User, err error)
	inspectFuncGetUserByTelegramID   func(ctx context.Context, i1 int)
	afterGetUserByTelegramIDCounter  uint64
	beforeGetUserByTelegramIDCounter uint64
	GetUserByTelegramIDMock          mRepositoryMockGetUserByTelegramID

	funcGetUsersByIDs          func(ctx context.Context, ia1 []int64) (ua1 []models.User, err error)
	inspectFuncGetUsersByIDs   func(ctx context.Context, ia1 []int64)
	afterGetUsersByIDsCounter  uint64
	beforeGetUsersByIDsCounter uint64
	GetUsersByIDsMock          mRepositoryMockGetUsersByIDs

	funcReadSubscriber          func(ctx context.Context, i1 int) (s1 models.Subscriber, err error)
	inspectFuncReadSubscriber   func(ctx context.Context, i1 int)
	afterReadSubscriberCounter  uint64
	beforeReadSubscriberCounter uint64
	ReadSubscriberMock          mRepositoryMockReadSubscriber

	funcReadSubscription          func(ctx context.Context, i1 int) (s1 models.Subscription, err error)
	inspectFuncReadSubscription   func(ctx context.Context, i1 int)
	afterReadSubscriptionCounter  uint64
	beforeReadSubscriptionCounter uint64
	ReadSubscriptionMock          mRepositoryMockReadSubscription

	funcReadUser          func(ctx context.Context, i1 int) (u1 models.User, err error)
	inspectFuncReadUser   func(ctx context.Context, i1 int)
	afterReadUserCounter  uint64
	beforeReadUserCounter uint64
	ReadUserMock          mRepositoryMockReadUser

	funcUpdateSubscriber          func(ctx context.Context, s1 models.Subscriber) (err error)
	inspectFuncUpdateSubscriber   func(ctx context.Context, s1 models.Subscriber)
	afterUpdateSubscriberCounter  uint64
	beforeUpdateSubscriberCounter uint64
	UpdateSubscriberMock          mRepositoryMockUpdateSubscriber

	funcUpdateSubscription          func(ctx context.Context, s1 models.Subscription) (err error)
	inspectFuncUpdateSubscription   func(ctx context.Context, s1 models.Subscription)
	afterUpdateSubscriptionCounter  uint64
	beforeUpdateSubscriptionCounter uint64
	UpdateSubscriptionMock          mRepositoryMockUpdateSubscription

	funcUpdateUser          func(ctx context.Context, u1 models.User) (err error)
	inspectFuncUpdateUser   func(ctx context.Context, u1 models.User)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mRepositoryMockUpdateUser
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSubscriberMock = mRepositoryMockCreateSubscriber{mock: m}
	m.CreateSubscriberMock.callArgs = []*RepositoryMockCreateSubscriberParams{}

	m.CreateSubscriptionMock = mRepositoryMockCreateSubscription{mock: m}
	m.CreateSubscriptionMock.callArgs = []*RepositoryMockCreateSubscriptionParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.DeleteSubscriberMock = mRepositoryMockDeleteSubscriber{mock: m}
	m.DeleteSubscriberMock.callArgs = []*RepositoryMockDeleteSubscriberParams{}

	m.DeleteSubscriptionMock = mRepositoryMockDeleteSubscription{mock: m}
	m.DeleteSubscriptionMock.callArgs = []*RepositoryMockDeleteSubscriptionParams{}

	m.DeleteUserMock = mRepositoryMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*RepositoryMockDeleteUserParams{}

	m.GetSubscribersForSubscriptionMock = mRepositoryMockGetSubscribersForSubscription{mock: m}
	m.GetSubscribersForSubscriptionMock.callArgs = []*RepositoryMockGetSubscribersForSubscriptionParams{}

	m.GetSubscriptionsForUserMock = mRepositoryMockGetSubscriptionsForUser{mock: m}
	m.GetSubscriptionsForUserMock.callArgs = []*RepositoryMockGetSubscriptionsForUserParams{}

	m.GetUserByTelegramIDMock = mRepositoryMockGetUserByTelegramID{mock: m}
	m.GetUserByTelegramIDMock.callArgs = []*RepositoryMockGetUserByTelegramIDParams{}

	m.GetUsersByIDsMock = mRepositoryMockGetUsersByIDs{mock: m}
	m.GetUsersByIDsMock.callArgs = []*RepositoryMockGetUsersByIDsParams{}

	m.ReadSubscriberMock = mRepositoryMockReadSubscriber{mock: m}
	m.ReadSubscriberMock.callArgs = []*RepositoryMockReadSubscriberParams{}

	m.ReadSubscriptionMock = mRepositoryMockReadSubscription{mock: m}
	m.ReadSubscriptionMock.callArgs = []*RepositoryMockReadSubscriptionParams{}

	m.ReadUserMock = mRepositoryMockReadUser{mock: m}
	m.ReadUserMock.callArgs = []*RepositoryMockReadUserParams{}

	m.UpdateSubscriberMock = mRepositoryMockUpdateSubscriber{mock: m}
	m.UpdateSubscriberMock.callArgs = []*RepositoryMockUpdateSubscriberParams{}

	m.UpdateSubscriptionMock = mRepositoryMockUpdateSubscription{mock: m}
	m.UpdateSubscriptionMock.callArgs = []*RepositoryMockUpdateSubscriptionParams{}

	m.UpdateUserMock = mRepositoryMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*RepositoryMockUpdateUserParams{}

	return m
}

type mRepositoryMockCreateSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSubscriberExpectation
	expectations       []*RepositoryMockCreateSubscriberExpectation

	callArgs []*RepositoryMockCreateSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateSubscriberExpectation specifies expectation struct of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateSubscriberParams
	results *RepositoryMockCreateSubscriberResults
	Counter uint64
}

// RepositoryMockCreateSubscriberParams contains parameters of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberParams struct {
	ctx context.Context
	s1  models.Subscriber
}

// RepositoryMockCreateSubscriberResults contains results of the Repository.CreateSubscriber
type RepositoryMockCreateSubscriberResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Expect(ctx context.Context, s1 models.Subscriber) *mRepositoryMockCreateSubscriber {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &RepositoryMockCreateSubscriberExpectation{}
	}

	mmCreateSubscriber.defaultExpectation.params = &RepositoryMockCreateSubscriberParams{ctx, s1}
	for _, e := range mmCreateSubscriber.expectations {
		if minimock.Equal(e.params, mmCreateSubscriber.defaultExpectation.params) {
			mmCreateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscriber.defaultExpectation.params)
		}
	}

	return mmCreateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Inspect(f func(ctx context.Context, s1 models.Subscriber)) *mRepositoryMockCreateSubscriber {
	if mmCreateSubscriber.mock.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSubscriber")
	}

	mmCreateSubscriber.mock.inspectFuncCreateSubscriber = f

	return mmCreateSubscriber
}

// Return sets up results that will be returned by Repository.CreateSubscriber
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Return(i1 int, err error) *RepositoryMock {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	if mmCreateSubscriber.defaultExpectation == nil {
		mmCreateSubscriber.defaultExpectation = &RepositoryMockCreateSubscriberExpectation{mock: mmCreateSubscriber.mock}
	}
	mmCreateSubscriber.defaultExpectation.results = &RepositoryMockCreateSubscriberResults{i1, err}
	return mmCreateSubscriber.mock
}

//Set uses given function f to mock the Repository.CreateSubscriber method
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Set(f func(ctx context.Context, s1 models.Subscriber) (i1 int, err error)) *RepositoryMock {
	if mmCreateSubscriber.defaultExpectation != nil {
		mmCreateSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSubscriber method")
	}

	if len(mmCreateSubscriber.expectations) > 0 {
		mmCreateSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSubscriber method")
	}

	mmCreateSubscriber.mock.funcCreateSubscriber = f
	return mmCreateSubscriber.mock
}

// When sets expectation for the Repository.CreateSubscriber which will trigger the result defined by the following
// Then helper
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) When(ctx context.Context, s1 models.Subscriber) *RepositoryMockCreateSubscriberExpectation {
	if mmCreateSubscriber.mock.funcCreateSubscriber != nil {
		mmCreateSubscriber.mock.t.Fatalf("RepositoryMock.CreateSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSubscriberExpectation{
		mock:   mmCreateSubscriber.mock,
		params: &RepositoryMockCreateSubscriberParams{ctx, s1},
	}
	mmCreateSubscriber.expectations = append(mmCreateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSubscriberExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSubscriberResults{i1, err}
	return e.mock
}

// CreateSubscriber implements Repository
func (mmCreateSubscriber *RepositoryMock) CreateSubscriber(ctx context.Context, s1 models.Subscriber) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscriber.afterCreateSubscriberCounter, 1)

	if mmCreateSubscriber.inspectFuncCreateSubscriber != nil {
		mmCreateSubscriber.inspectFuncCreateSubscriber(ctx, s1)
	}

	mm_params := &RepositoryMockCreateSubscriberParams{ctx, s1}

	// Record call args
	mmCreateSubscriber.CreateSubscriberMock.mutex.Lock()
	mmCreateSubscriber.CreateSubscriberMock.callArgs = append(mmCreateSubscriber.CreateSubscriberMock.callArgs, mm_params)
	mmCreateSubscriber.CreateSubscriberMock.mutex.Unlock()

	for _, e := range mmCreateSubscriber.CreateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateSubscriber.CreateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockCreateSubscriberParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscriber.t.Errorf("RepositoryMock.CreateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscriber.CreateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscriber.t.Fatal("No results are set for the RepositoryMock.CreateSubscriber")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateSubscriber.funcCreateSubscriber != nil {
		return mmCreateSubscriber.funcCreateSubscriber(ctx, s1)
	}
	mmCreateSubscriber.t.Fatalf("Unexpected call to RepositoryMock.CreateSubscriber. %v %v", ctx, s1)
	return
}

// CreateSubscriberAfterCounter returns a count of finished RepositoryMock.CreateSubscriber invocations
func (mmCreateSubscriber *RepositoryMock) CreateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.afterCreateSubscriberCounter)
}

// CreateSubscriberBeforeCounter returns a count of RepositoryMock.CreateSubscriber invocations
func (mmCreateSubscriber *RepositoryMock) CreateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscriber.beforeCreateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscriber *mRepositoryMockCreateSubscriber) Calls() []*RepositoryMockCreateSubscriberParams {
	mmCreateSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSubscriberParams, len(mmCreateSubscriber.callArgs))
	copy(argCopy, mmCreateSubscriber.callArgs)

	mmCreateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriberDone returns true if the count of the CreateSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSubscriberDone() bool {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSubscriberInspect() {
	for _, e := range m.CreateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		if m.CreateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscriber with params: %#v", *m.CreateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscriber != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateSubscriber")
	}
}

type mRepositoryMockCreateSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSubscriptionExpectation
	expectations       []*RepositoryMockCreateSubscriptionExpectation

	callArgs []*RepositoryMockCreateSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateSubscriptionExpectation specifies expectation struct of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateSubscriptionParams
	results *RepositoryMockCreateSubscriptionResults
	Counter uint64
}

// RepositoryMockCreateSubscriptionParams contains parameters of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionParams struct {
	ctx context.Context
	s1  models.Subscription
}

// RepositoryMockCreateSubscriptionResults contains results of the Repository.CreateSubscription
type RepositoryMockCreateSubscriptionResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Expect(ctx context.Context, s1 models.Subscription) *mRepositoryMockCreateSubscription {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &RepositoryMockCreateSubscriptionExpectation{}
	}

	mmCreateSubscription.defaultExpectation.params = &RepositoryMockCreateSubscriptionParams{ctx, s1}
	for _, e := range mmCreateSubscription.expectations {
		if minimock.Equal(e.params, mmCreateSubscription.defaultExpectation.params) {
			mmCreateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSubscription.defaultExpectation.params)
		}
	}

	return mmCreateSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Inspect(f func(ctx context.Context, s1 models.Subscription)) *mRepositoryMockCreateSubscription {
	if mmCreateSubscription.mock.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSubscription")
	}

	mmCreateSubscription.mock.inspectFuncCreateSubscription = f

	return mmCreateSubscription
}

// Return sets up results that will be returned by Repository.CreateSubscription
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Return(i1 int, err error) *RepositoryMock {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	if mmCreateSubscription.defaultExpectation == nil {
		mmCreateSubscription.defaultExpectation = &RepositoryMockCreateSubscriptionExpectation{mock: mmCreateSubscription.mock}
	}
	mmCreateSubscription.defaultExpectation.results = &RepositoryMockCreateSubscriptionResults{i1, err}
	return mmCreateSubscription.mock
}

//Set uses given function f to mock the Repository.CreateSubscription method
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Set(f func(ctx context.Context, s1 models.Subscription) (i1 int, err error)) *RepositoryMock {
	if mmCreateSubscription.defaultExpectation != nil {
		mmCreateSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSubscription method")
	}

	if len(mmCreateSubscription.expectations) > 0 {
		mmCreateSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSubscription method")
	}

	mmCreateSubscription.mock.funcCreateSubscription = f
	return mmCreateSubscription.mock
}

// When sets expectation for the Repository.CreateSubscription which will trigger the result defined by the following
// Then helper
func (mmCreateSubscription *mRepositoryMockCreateSubscription) When(ctx context.Context, s1 models.Subscription) *RepositoryMockCreateSubscriptionExpectation {
	if mmCreateSubscription.mock.funcCreateSubscription != nil {
		mmCreateSubscription.mock.t.Fatalf("RepositoryMock.CreateSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSubscriptionExpectation{
		mock:   mmCreateSubscription.mock,
		params: &RepositoryMockCreateSubscriptionParams{ctx, s1},
	}
	mmCreateSubscription.expectations = append(mmCreateSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSubscriptionExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSubscriptionResults{i1, err}
	return e.mock
}

// CreateSubscription implements Repository
func (mmCreateSubscription *RepositoryMock) CreateSubscription(ctx context.Context, s1 models.Subscription) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSubscription.afterCreateSubscriptionCounter, 1)

	if mmCreateSubscription.inspectFuncCreateSubscription != nil {
		mmCreateSubscription.inspectFuncCreateSubscription(ctx, s1)
	}

	mm_params := &RepositoryMockCreateSubscriptionParams{ctx, s1}

	// Record call args
	mmCreateSubscription.CreateSubscriptionMock.mutex.Lock()
	mmCreateSubscription.CreateSubscriptionMock.callArgs = append(mmCreateSubscription.CreateSubscriptionMock.callArgs, mm_params)
	mmCreateSubscription.CreateSubscriptionMock.mutex.Unlock()

	for _, e := range mmCreateSubscription.CreateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateSubscription.CreateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockCreateSubscriptionParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSubscription.t.Errorf("RepositoryMock.CreateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSubscription.CreateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSubscription.t.Fatal("No results are set for the RepositoryMock.CreateSubscription")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateSubscription.funcCreateSubscription != nil {
		return mmCreateSubscription.funcCreateSubscription(ctx, s1)
	}
	mmCreateSubscription.t.Fatalf("Unexpected call to RepositoryMock.CreateSubscription. %v %v", ctx, s1)
	return
}

// CreateSubscriptionAfterCounter returns a count of finished RepositoryMock.CreateSubscription invocations
func (mmCreateSubscription *RepositoryMock) CreateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.afterCreateSubscriptionCounter)
}

// CreateSubscriptionBeforeCounter returns a count of RepositoryMock.CreateSubscription invocations
func (mmCreateSubscription *RepositoryMock) CreateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSubscription.beforeCreateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSubscription *mRepositoryMockCreateSubscription) Calls() []*RepositoryMockCreateSubscriptionParams {
	mmCreateSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSubscriptionParams, len(mmCreateSubscription.callArgs))
	copy(argCopy, mmCreateSubscription.callArgs)

	mmCreateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSubscriptionDone returns true if the count of the CreateSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSubscriptionDone() bool {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSubscriptionInspect() {
	for _, e := range m.CreateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		if m.CreateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSubscription with params: %#v", *m.CreateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSubscription != nil && mm_atomic.LoadUint64(&m.afterCreateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateSubscription")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx context.Context
	u1  models.User
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context, u1 models.User) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx, u1}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context, u1 models.User)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(i1 int, err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{i1, err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context, u1 models.User) (i1 int, err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context, u1 models.User) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx, u1},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(i1 int, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{i1, err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context, u1 models.User) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, u1)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx, u1}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, u1)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v %v", ctx, u1)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

type mRepositoryMockDeleteSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSubscriberExpectation
	expectations       []*RepositoryMockDeleteSubscriberExpectation

	callArgs []*RepositoryMockDeleteSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteSubscriberExpectation specifies expectation struct of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteSubscriberParams
	results *RepositoryMockDeleteSubscriberResults
	Counter uint64
}

// RepositoryMockDeleteSubscriberParams contains parameters of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteSubscriberResults contains results of the Repository.DeleteSubscriber
type RepositoryMockDeleteSubscriberResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &RepositoryMockDeleteSubscriberExpectation{}
	}

	mmDeleteSubscriber.defaultExpectation.params = &RepositoryMockDeleteSubscriberParams{ctx, i1}
	for _, e := range mmDeleteSubscriber.expectations {
		if minimock.Equal(e.params, mmDeleteSubscriber.defaultExpectation.params) {
			mmDeleteSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscriber.defaultExpectation.params)
		}
	}

	return mmDeleteSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteSubscriber {
	if mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSubscriber")
	}

	mmDeleteSubscriber.mock.inspectFuncDeleteSubscriber = f

	return mmDeleteSubscriber
}

// Return sets up results that will be returned by Repository.DeleteSubscriber
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Return(err error) *RepositoryMock {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	if mmDeleteSubscriber.defaultExpectation == nil {
		mmDeleteSubscriber.defaultExpectation = &RepositoryMockDeleteSubscriberExpectation{mock: mmDeleteSubscriber.mock}
	}
	mmDeleteSubscriber.defaultExpectation.results = &RepositoryMockDeleteSubscriberResults{err}
	return mmDeleteSubscriber.mock
}

//Set uses given function f to mock the Repository.DeleteSubscriber method
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteSubscriber.defaultExpectation != nil {
		mmDeleteSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSubscriber method")
	}

	if len(mmDeleteSubscriber.expectations) > 0 {
		mmDeleteSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSubscriber method")
	}

	mmDeleteSubscriber.mock.funcDeleteSubscriber = f
	return mmDeleteSubscriber.mock
}

// When sets expectation for the Repository.DeleteSubscriber which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) When(ctx context.Context, i1 int) *RepositoryMockDeleteSubscriberExpectation {
	if mmDeleteSubscriber.mock.funcDeleteSubscriber != nil {
		mmDeleteSubscriber.mock.t.Fatalf("RepositoryMock.DeleteSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSubscriberExpectation{
		mock:   mmDeleteSubscriber.mock,
		params: &RepositoryMockDeleteSubscriberParams{ctx, i1},
	}
	mmDeleteSubscriber.expectations = append(mmDeleteSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSubscriberExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSubscriberResults{err}
	return e.mock
}

// DeleteSubscriber implements Repository
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriber(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter, 1)

	if mmDeleteSubscriber.inspectFuncDeleteSubscriber != nil {
		mmDeleteSubscriber.inspectFuncDeleteSubscriber(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteSubscriberParams{ctx, i1}

	// Record call args
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Lock()
	mmDeleteSubscriber.DeleteSubscriberMock.callArgs = append(mmDeleteSubscriber.DeleteSubscriberMock.callArgs, mm_params)
	mmDeleteSubscriber.DeleteSubscriberMock.mutex.Unlock()

	for _, e := range mmDeleteSubscriber.DeleteSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteSubscriberParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscriber.t.Errorf("RepositoryMock.DeleteSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscriber.DeleteSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscriber.t.Fatal("No results are set for the RepositoryMock.DeleteSubscriber")
		}
		return (*mm_results).err
	}
	if mmDeleteSubscriber.funcDeleteSubscriber != nil {
		return mmDeleteSubscriber.funcDeleteSubscriber(ctx, i1)
	}
	mmDeleteSubscriber.t.Fatalf("Unexpected call to RepositoryMock.DeleteSubscriber. %v %v", ctx, i1)
	return
}

// DeleteSubscriberAfterCounter returns a count of finished RepositoryMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.afterDeleteSubscriberCounter)
}

// DeleteSubscriberBeforeCounter returns a count of RepositoryMock.DeleteSubscriber invocations
func (mmDeleteSubscriber *RepositoryMock) DeleteSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscriber.beforeDeleteSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscriber *mRepositoryMockDeleteSubscriber) Calls() []*RepositoryMockDeleteSubscriberParams {
	mmDeleteSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSubscriberParams, len(mmDeleteSubscriber.callArgs))
	copy(argCopy, mmDeleteSubscriber.callArgs)

	mmDeleteSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriberDone returns true if the count of the DeleteSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSubscriberDone() bool {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSubscriberInspect() {
	for _, e := range m.DeleteSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		if m.DeleteSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscriber with params: %#v", *m.DeleteSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscriber != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteSubscriber")
	}
}

type mRepositoryMockDeleteSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSubscriptionExpectation
	expectations       []*RepositoryMockDeleteSubscriptionExpectation

	callArgs []*RepositoryMockDeleteSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteSubscriptionExpectation specifies expectation struct of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteSubscriptionParams
	results *RepositoryMockDeleteSubscriptionResults
	Counter uint64
}

// RepositoryMockDeleteSubscriptionParams contains parameters of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteSubscriptionResults contains results of the Repository.DeleteSubscription
type RepositoryMockDeleteSubscriptionResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteSubscription {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &RepositoryMockDeleteSubscriptionExpectation{}
	}

	mmDeleteSubscription.defaultExpectation.params = &RepositoryMockDeleteSubscriptionParams{ctx, i1}
	for _, e := range mmDeleteSubscription.expectations {
		if minimock.Equal(e.params, mmDeleteSubscription.defaultExpectation.params) {
			mmDeleteSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSubscription.defaultExpectation.params)
		}
	}

	return mmDeleteSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteSubscription {
	if mmDeleteSubscription.mock.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSubscription")
	}

	mmDeleteSubscription.mock.inspectFuncDeleteSubscription = f

	return mmDeleteSubscription
}

// Return sets up results that will be returned by Repository.DeleteSubscription
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Return(err error) *RepositoryMock {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	if mmDeleteSubscription.defaultExpectation == nil {
		mmDeleteSubscription.defaultExpectation = &RepositoryMockDeleteSubscriptionExpectation{mock: mmDeleteSubscription.mock}
	}
	mmDeleteSubscription.defaultExpectation.results = &RepositoryMockDeleteSubscriptionResults{err}
	return mmDeleteSubscription.mock
}

//Set uses given function f to mock the Repository.DeleteSubscription method
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteSubscription.defaultExpectation != nil {
		mmDeleteSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSubscription method")
	}

	if len(mmDeleteSubscription.expectations) > 0 {
		mmDeleteSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSubscription method")
	}

	mmDeleteSubscription.mock.funcDeleteSubscription = f
	return mmDeleteSubscription.mock
}

// When sets expectation for the Repository.DeleteSubscription which will trigger the result defined by the following
// Then helper
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) When(ctx context.Context, i1 int) *RepositoryMockDeleteSubscriptionExpectation {
	if mmDeleteSubscription.mock.funcDeleteSubscription != nil {
		mmDeleteSubscription.mock.t.Fatalf("RepositoryMock.DeleteSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSubscriptionExpectation{
		mock:   mmDeleteSubscription.mock,
		params: &RepositoryMockDeleteSubscriptionParams{ctx, i1},
	}
	mmDeleteSubscription.expectations = append(mmDeleteSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSubscriptionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSubscriptionResults{err}
	return e.mock
}

// DeleteSubscription implements Repository
func (mmDeleteSubscription *RepositoryMock) DeleteSubscription(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter, 1)

	if mmDeleteSubscription.inspectFuncDeleteSubscription != nil {
		mmDeleteSubscription.inspectFuncDeleteSubscription(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteSubscriptionParams{ctx, i1}

	// Record call args
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Lock()
	mmDeleteSubscription.DeleteSubscriptionMock.callArgs = append(mmDeleteSubscription.DeleteSubscriptionMock.callArgs, mm_params)
	mmDeleteSubscription.DeleteSubscriptionMock.mutex.Unlock()

	for _, e := range mmDeleteSubscription.DeleteSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteSubscriptionParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSubscription.t.Errorf("RepositoryMock.DeleteSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSubscription.DeleteSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSubscription.t.Fatal("No results are set for the RepositoryMock.DeleteSubscription")
		}
		return (*mm_results).err
	}
	if mmDeleteSubscription.funcDeleteSubscription != nil {
		return mmDeleteSubscription.funcDeleteSubscription(ctx, i1)
	}
	mmDeleteSubscription.t.Fatalf("Unexpected call to RepositoryMock.DeleteSubscription. %v %v", ctx, i1)
	return
}

// DeleteSubscriptionAfterCounter returns a count of finished RepositoryMock.DeleteSubscription invocations
func (mmDeleteSubscription *RepositoryMock) DeleteSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.afterDeleteSubscriptionCounter)
}

// DeleteSubscriptionBeforeCounter returns a count of RepositoryMock.DeleteSubscription invocations
func (mmDeleteSubscription *RepositoryMock) DeleteSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSubscription.beforeDeleteSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSubscription *mRepositoryMockDeleteSubscription) Calls() []*RepositoryMockDeleteSubscriptionParams {
	mmDeleteSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSubscriptionParams, len(mmDeleteSubscription.callArgs))
	copy(argCopy, mmDeleteSubscription.callArgs)

	mmDeleteSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSubscriptionDone returns true if the count of the DeleteSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSubscriptionDone() bool {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSubscriptionInspect() {
	for _, e := range m.DeleteSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		if m.DeleteSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSubscription with params: %#v", *m.DeleteSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSubscription != nil && mm_atomic.LoadUint64(&m.afterDeleteSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteSubscription")
	}
}

type mRepositoryMockDeleteUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteUserExpectation
	expectations       []*RepositoryMockDeleteUserExpectation

	callArgs []*RepositoryMockDeleteUserParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteUserExpectation specifies expectation struct of the Repository.DeleteUser
type RepositoryMockDeleteUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteUserParams
	results *RepositoryMockDeleteUserResults
	Counter uint64
}

// RepositoryMockDeleteUserParams contains parameters of the Repository.DeleteUser
type RepositoryMockDeleteUserParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockDeleteUserResults contains results of the Repository.DeleteUser
type RepositoryMockDeleteUserResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Expect(ctx context.Context, i1 int) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{}
	}

	mmDeleteUser.defaultExpectation.params = &RepositoryMockDeleteUserParams{ctx, i1}
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by Repository.DeleteUser
func (mmDeleteUser *mRepositoryMockDeleteUser) Return(err error) *RepositoryMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &RepositoryMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &RepositoryMockDeleteUserResults{err}
	return mmDeleteUser.mock
}

//Set uses given function f to mock the Repository.DeleteUser method
func (mmDeleteUser *mRepositoryMockDeleteUser) Set(f func(ctx context.Context, i1 int) (err error)) *RepositoryMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	return mmDeleteUser.mock
}

// When sets expectation for the Repository.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mRepositoryMockDeleteUser) When(ctx context.Context, i1 int) *RepositoryMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("RepositoryMock.DeleteUser mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteUserExpectation{
		mock:   mmDeleteUser.mock,
		params: &RepositoryMockDeleteUserParams{ctx, i1},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteUserResults{err}
	return e.mock
}

// DeleteUser implements Repository
func (mmDeleteUser *RepositoryMock) DeleteUser(ctx context.Context, i1 int) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, i1)
	}

	mm_params := &RepositoryMockDeleteUserParams{ctx, i1}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteUserParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("RepositoryMock.DeleteUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the RepositoryMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, i1)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to RepositoryMock.DeleteUser. %v %v", ctx, i1)
	return
}

// DeleteUserAfterCounter returns a count of finished RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of RepositoryMock.DeleteUser invocations
func (mmDeleteUser *RepositoryMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mRepositoryMockDeleteUser) Calls() []*RepositoryMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteUserDone() bool {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteUser with params: %#v", *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteUser")
	}
}

type mRepositoryMockGetSubscribersForSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSubscribersForSubscriptionExpectation
	expectations       []*RepositoryMockGetSubscribersForSubscriptionExpectation

	callArgs []*RepositoryMockGetSubscribersForSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSubscribersForSubscriptionExpectation specifies expectation struct of the Repository.GetSubscribersForSubscription
type RepositoryMockGetSubscribersForSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSubscribersForSubscriptionParams
	results *RepositoryMockGetSubscribersForSubscriptionResults
	Counter uint64
}

// RepositoryMockGetSubscribersForSubscriptionParams contains parameters of the Repository.GetSubscribersForSubscription
type RepositoryMockGetSubscribersForSubscriptionParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetSubscribersForSubscriptionResults contains results of the Repository.GetSubscribersForSubscription
type RepositoryMockGetSubscribersForSubscriptionResults struct {
	sa1 []models.Subscriber
	err error
}

// Expect sets up expected params for Repository.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) Expect(ctx context.Context, i1 int) *mRepositoryMockGetSubscribersForSubscription {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("RepositoryMock.GetSubscribersForSubscription mock is already set by Set")
	}

	if mmGetSubscribersForSubscription.defaultExpectation == nil {
		mmGetSubscribersForSubscription.defaultExpectation = &RepositoryMockGetSubscribersForSubscriptionExpectation{}
	}

	mmGetSubscribersForSubscription.defaultExpectation.params = &RepositoryMockGetSubscribersForSubscriptionParams{ctx, i1}
	for _, e := range mmGetSubscribersForSubscription.expectations {
		if minimock.Equal(e.params, mmGetSubscribersForSubscription.defaultExpectation.params) {
			mmGetSubscribersForSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscribersForSubscription.defaultExpectation.params)
		}
	}

	return mmGetSubscribersForSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetSubscribersForSubscription {
	if mmGetSubscribersForSubscription.mock.inspectFuncGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSubscribersForSubscription")
	}

	mmGetSubscribersForSubscription.mock.inspectFuncGetSubscribersForSubscription = f

	return mmGetSubscribersForSubscription
}

// Return sets up results that will be returned by Repository.GetSubscribersForSubscription
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) Return(sa1 []models.Subscriber, err error) *RepositoryMock {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("RepositoryMock.GetSubscribersForSubscription mock is already set by Set")
	}

	if mmGetSubscribersForSubscription.defaultExpectation == nil {
		mmGetSubscribersForSubscription.defaultExpectation = &RepositoryMockGetSubscribersForSubscriptionExpectation{mock: mmGetSubscribersForSubscription.mock}
	}
	mmGetSubscribersForSubscription.defaultExpectation.results = &RepositoryMockGetSubscribersForSubscriptionResults{sa1, err}
	return mmGetSubscribersForSubscription.mock
}

//Set uses given function f to mock the Repository.GetSubscribersForSubscription method
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) Set(f func(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error)) *RepositoryMock {
	if mmGetSubscribersForSubscription.defaultExpectation != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.GetSubscribersForSubscription method")
	}

	if len(mmGetSubscribersForSubscription.expectations) > 0 {
		mmGetSubscribersForSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.GetSubscribersForSubscription method")
	}

	mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription = f
	return mmGetSubscribersForSubscription.mock
}

// When sets expectation for the Repository.GetSubscribersForSubscription which will trigger the result defined by the following
// Then helper
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) When(ctx context.Context, i1 int) *RepositoryMockGetSubscribersForSubscriptionExpectation {
	if mmGetSubscribersForSubscription.mock.funcGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.mock.t.Fatalf("RepositoryMock.GetSubscribersForSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockGetSubscribersForSubscriptionExpectation{
		mock:   mmGetSubscribersForSubscription.mock,
		params: &RepositoryMockGetSubscribersForSubscriptionParams{ctx, i1},
	}
	mmGetSubscribersForSubscription.expectations = append(mmGetSubscribersForSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSubscribersForSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSubscribersForSubscriptionExpectation) Then(sa1 []models.Subscriber, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSubscribersForSubscriptionResults{sa1, err}
	return e.mock
}

// GetSubscribersForSubscription implements Repository
func (mmGetSubscribersForSubscription *RepositoryMock) GetSubscribersForSubscription(ctx context.Context, i1 int) (sa1 []models.Subscriber, err error) {
	mm_atomic.AddUint64(&mmGetSubscribersForSubscription.beforeGetSubscribersForSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscribersForSubscription.afterGetSubscribersForSubscriptionCounter, 1)

	if mmGetSubscribersForSubscription.inspectFuncGetSubscribersForSubscription != nil {
		mmGetSubscribersForSubscription.inspectFuncGetSubscribersForSubscription(ctx, i1)
	}

	mm_params := &RepositoryMockGetSubscribersForSubscriptionParams{ctx, i1}

	// Record call args
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.mutex.Lock()
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.callArgs = append(mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.callArgs, mm_params)
	mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.mutex.Unlock()

	for _, e := range mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockGetSubscribersForSubscriptionParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscribersForSubscription.t.Errorf("RepositoryMock.GetSubscribersForSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscribersForSubscription.GetSubscribersForSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscribersForSubscription.t.Fatal("No results are set for the RepositoryMock.GetSubscribersForSubscription")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSubscribersForSubscription.funcGetSubscribersForSubscription != nil {
		return mmGetSubscribersForSubscription.funcGetSubscribersForSubscription(ctx, i1)
	}
	mmGetSubscribersForSubscription.t.Fatalf("Unexpected call to RepositoryMock.GetSubscribersForSubscription. %v %v", ctx, i1)
	return
}

// GetSubscribersForSubscriptionAfterCounter returns a count of finished RepositoryMock.GetSubscribersForSubscription invocations
func (mmGetSubscribersForSubscription *RepositoryMock) GetSubscribersForSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribersForSubscription.afterGetSubscribersForSubscriptionCounter)
}

// GetSubscribersForSubscriptionBeforeCounter returns a count of RepositoryMock.GetSubscribersForSubscription invocations
func (mmGetSubscribersForSubscription *RepositoryMock) GetSubscribersForSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscribersForSubscription.beforeGetSubscribersForSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSubscribersForSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscribersForSubscription *mRepositoryMockGetSubscribersForSubscription) Calls() []*RepositoryMockGetSubscribersForSubscriptionParams {
	mmGetSubscribersForSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSubscribersForSubscriptionParams, len(mmGetSubscribersForSubscription.callArgs))
	copy(argCopy, mmGetSubscribersForSubscription.callArgs)

	mmGetSubscribersForSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscribersForSubscriptionDone returns true if the count of the GetSubscribersForSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSubscribersForSubscriptionDone() bool {
	for _, e := range m.GetSubscribersForSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersForSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribersForSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscribersForSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSubscribersForSubscriptionInspect() {
	for _, e := range m.GetSubscribersForSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscribersForSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscribersForSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		if m.GetSubscribersForSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSubscribersForSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscribersForSubscription with params: %#v", *m.GetSubscribersForSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscribersForSubscription != nil && mm_atomic.LoadUint64(&m.afterGetSubscribersForSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSubscribersForSubscription")
	}
}

type mRepositoryMockGetSubscriptionsForUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSubscriptionsForUserExpectation
	expectations       []*RepositoryMockGetSubscriptionsForUserExpectation

	callArgs []*RepositoryMockGetSubscriptionsForUserParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSubscriptionsForUserExpectation specifies expectation struct of the Repository.GetSubscriptionsForUser
type RepositoryMockGetSubscriptionsForUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSubscriptionsForUserParams
	results *RepositoryMockGetSubscriptionsForUserResults
	Counter uint64
}

// RepositoryMockGetSubscriptionsForUserParams contains parameters of the Repository.GetSubscriptionsForUser
type RepositoryMockGetSubscriptionsForUserParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetSubscriptionsForUserResults contains results of the Repository.GetSubscriptionsForUser
type RepositoryMockGetSubscriptionsForUserResults struct {
	sa1 []models.Subscription
	err error
}

// Expect sets up expected params for Repository.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) Expect(ctx context.Context, i1 int) *mRepositoryMockGetSubscriptionsForUser {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("RepositoryMock.GetSubscriptionsForUser mock is already set by Set")
	}

	if mmGetSubscriptionsForUser.defaultExpectation == nil {
		mmGetSubscriptionsForUser.defaultExpectation = &RepositoryMockGetSubscriptionsForUserExpectation{}
	}

	mmGetSubscriptionsForUser.defaultExpectation.params = &RepositoryMockGetSubscriptionsForUserParams{ctx, i1}
	for _, e := range mmGetSubscriptionsForUser.expectations {
		if minimock.Equal(e.params, mmGetSubscriptionsForUser.defaultExpectation.params) {
			mmGetSubscriptionsForUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSubscriptionsForUser.defaultExpectation.params)
		}
	}

	return mmGetSubscriptionsForUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetSubscriptionsForUser {
	if mmGetSubscriptionsForUser.mock.inspectFuncGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSubscriptionsForUser")
	}

	mmGetSubscriptionsForUser.mock.inspectFuncGetSubscriptionsForUser = f

	return mmGetSubscriptionsForUser
}

// Return sets up results that will be returned by Repository.GetSubscriptionsForUser
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) Return(sa1 []models.Subscription, err error) *RepositoryMock {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("RepositoryMock.GetSubscriptionsForUser mock is already set by Set")
	}

	if mmGetSubscriptionsForUser.defaultExpectation == nil {
		mmGetSubscriptionsForUser.defaultExpectation = &RepositoryMockGetSubscriptionsForUserExpectation{mock: mmGetSubscriptionsForUser.mock}
	}
	mmGetSubscriptionsForUser.defaultExpectation.results = &RepositoryMockGetSubscriptionsForUserResults{sa1, err}
	return mmGetSubscriptionsForUser.mock
}

//Set uses given function f to mock the Repository.GetSubscriptionsForUser method
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) Set(f func(ctx context.Context, i1 int) (sa1 []models.Subscription, err error)) *RepositoryMock {
	if mmGetSubscriptionsForUser.defaultExpectation != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Default expectation is already set for the Repository.GetSubscriptionsForUser method")
	}

	if len(mmGetSubscriptionsForUser.expectations) > 0 {
		mmGetSubscriptionsForUser.mock.t.Fatalf("Some expectations are already set for the Repository.GetSubscriptionsForUser method")
	}

	mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser = f
	return mmGetSubscriptionsForUser.mock
}

// When sets expectation for the Repository.GetSubscriptionsForUser which will trigger the result defined by the following
// Then helper
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) When(ctx context.Context, i1 int) *RepositoryMockGetSubscriptionsForUserExpectation {
	if mmGetSubscriptionsForUser.mock.funcGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.mock.t.Fatalf("RepositoryMock.GetSubscriptionsForUser mock is already set by Set")
	}

	expectation := &RepositoryMockGetSubscriptionsForUserExpectation{
		mock:   mmGetSubscriptionsForUser.mock,
		params: &RepositoryMockGetSubscriptionsForUserParams{ctx, i1},
	}
	mmGetSubscriptionsForUser.expectations = append(mmGetSubscriptionsForUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSubscriptionsForUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSubscriptionsForUserExpectation) Then(sa1 []models.Subscription, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSubscriptionsForUserResults{sa1, err}
	return e.mock
}

// GetSubscriptionsForUser implements Repository
func (mmGetSubscriptionsForUser *RepositoryMock) GetSubscriptionsForUser(ctx context.Context, i1 int) (sa1 []models.Subscription, err error) {
	mm_atomic.AddUint64(&mmGetSubscriptionsForUser.beforeGetSubscriptionsForUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSubscriptionsForUser.afterGetSubscriptionsForUserCounter, 1)

	if mmGetSubscriptionsForUser.inspectFuncGetSubscriptionsForUser != nil {
		mmGetSubscriptionsForUser.inspectFuncGetSubscriptionsForUser(ctx, i1)
	}

	mm_params := &RepositoryMockGetSubscriptionsForUserParams{ctx, i1}

	// Record call args
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.mutex.Lock()
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.callArgs = append(mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.callArgs, mm_params)
	mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.mutex.Unlock()

	for _, e := range mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.params
		mm_got := RepositoryMockGetSubscriptionsForUserParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSubscriptionsForUser.t.Errorf("RepositoryMock.GetSubscriptionsForUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSubscriptionsForUser.GetSubscriptionsForUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSubscriptionsForUser.t.Fatal("No results are set for the RepositoryMock.GetSubscriptionsForUser")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetSubscriptionsForUser.funcGetSubscriptionsForUser != nil {
		return mmGetSubscriptionsForUser.funcGetSubscriptionsForUser(ctx, i1)
	}
	mmGetSubscriptionsForUser.t.Fatalf("Unexpected call to RepositoryMock.GetSubscriptionsForUser. %v %v", ctx, i1)
	return
}

// GetSubscriptionsForUserAfterCounter returns a count of finished RepositoryMock.GetSubscriptionsForUser invocations
func (mmGetSubscriptionsForUser *RepositoryMock) GetSubscriptionsForUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionsForUser.afterGetSubscriptionsForUserCounter)
}

// GetSubscriptionsForUserBeforeCounter returns a count of RepositoryMock.GetSubscriptionsForUser invocations
func (mmGetSubscriptionsForUser *RepositoryMock) GetSubscriptionsForUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSubscriptionsForUser.beforeGetSubscriptionsForUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSubscriptionsForUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSubscriptionsForUser *mRepositoryMockGetSubscriptionsForUser) Calls() []*RepositoryMockGetSubscriptionsForUserParams {
	mmGetSubscriptionsForUser.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSubscriptionsForUserParams, len(mmGetSubscriptionsForUser.callArgs))
	copy(argCopy, mmGetSubscriptionsForUser.callArgs)

	mmGetSubscriptionsForUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetSubscriptionsForUserDone returns true if the count of the GetSubscriptionsForUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSubscriptionsForUserDone() bool {
	for _, e := range m.GetSubscriptionsForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionsForUser != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSubscriptionsForUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSubscriptionsForUserInspect() {
	for _, e := range m.GetSubscriptionsForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscriptionsForUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSubscriptionsForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		if m.GetSubscriptionsForUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSubscriptionsForUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSubscriptionsForUser with params: %#v", *m.GetSubscriptionsForUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSubscriptionsForUser != nil && mm_atomic.LoadUint64(&m.afterGetSubscriptionsForUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSubscriptionsForUser")
	}
}

type mRepositoryMockGetUserByTelegramID struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUserByTelegramIDExpectation
	expectations       []*RepositoryMockGetUserByTelegramIDExpectation

	callArgs []*RepositoryMockGetUserByTelegramIDParams
	mutex    sync.RWMutex
}

// RepositoryMockGetUserByTelegramIDExpectation specifies expectation struct of the Repository.GetUserByTelegramID
type RepositoryMockGetUserByTelegramIDExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetUserByTelegramIDParams
	results *RepositoryMockGetUserByTelegramIDResults
	Counter uint64
}

// RepositoryMockGetUserByTelegramIDParams contains parameters of the Repository.GetUserByTelegramID
type RepositoryMockGetUserByTelegramIDParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetUserByTelegramIDResults contains results of the Repository.GetUserByTelegramID
type RepositoryMockGetUserByTelegramIDResults struct {
	u1  models.User
	err error
}

// Expect sets up expected params for Repository.GetUserByTelegramID
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) Expect(ctx context.Context, i1 int) *mRepositoryMockGetUserByTelegramID {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("RepositoryMock.GetUserByTelegramID mock is already set by Set")
	}

	if mmGetUserByTelegramID.defaultExpectation == nil {
		mmGetUserByTelegramID.defaultExpectation = &RepositoryMockGetUserByTelegramIDExpectation{}
	}

	mmGetUserByTelegramID.defaultExpectation.params = &RepositoryMockGetUserByTelegramIDParams{ctx, i1}
	for _, e := range mmGetUserByTelegramID.expectations {
		if minimock.Equal(e.params, mmGetUserByTelegramID.defaultExpectation.params) {
			mmGetUserByTelegramID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByTelegramID.defaultExpectation.params)
		}
	}

	return mmGetUserByTelegramID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUserByTelegramID
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetUserByTelegramID {
	if mmGetUserByTelegramID.mock.inspectFuncGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUserByTelegramID")
	}

	mmGetUserByTelegramID.mock.inspectFuncGetUserByTelegramID = f

	return mmGetUserByTelegramID
}

// Return sets up results that will be returned by Repository.GetUserByTelegramID
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) Return(u1 models.User, err error) *RepositoryMock {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("RepositoryMock.GetUserByTelegramID mock is already set by Set")
	}

	if mmGetUserByTelegramID.defaultExpectation == nil {
		mmGetUserByTelegramID.defaultExpectation = &RepositoryMockGetUserByTelegramIDExpectation{mock: mmGetUserByTelegramID.mock}
	}
	mmGetUserByTelegramID.defaultExpectation.results = &RepositoryMockGetUserByTelegramIDResults{u1, err}
	return mmGetUserByTelegramID.mock
}

//Set uses given function f to mock the Repository.GetUserByTelegramID method
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) Set(f func(ctx context.Context, i1 int) (u1 models.User, err error)) *RepositoryMock {
	if mmGetUserByTelegramID.defaultExpectation != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("Default expectation is already set for the Repository.GetUserByTelegramID method")
	}

	if len(mmGetUserByTelegramID.expectations) > 0 {
		mmGetUserByTelegramID.mock.t.Fatalf("Some expectations are already set for the Repository.GetUserByTelegramID method")
	}

	mmGetUserByTelegramID.mock.funcGetUserByTelegramID = f
	return mmGetUserByTelegramID.mock
}

// When sets expectation for the Repository.GetUserByTelegramID which will trigger the result defined by the following
// Then helper
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) When(ctx context.Context, i1 int) *RepositoryMockGetUserByTelegramIDExpectation {
	if mmGetUserByTelegramID.mock.funcGetUserByTelegramID != nil {
		mmGetUserByTelegramID.mock.t.Fatalf("RepositoryMock.GetUserByTelegramID mock is already set by Set")
	}

	expectation := &RepositoryMockGetUserByTelegramIDExpectation{
		mock:   mmGetUserByTelegramID.mock,
		params: &RepositoryMockGetUserByTelegramIDParams{ctx, i1},
	}
	mmGetUserByTelegramID.expectations = append(mmGetUserByTelegramID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUserByTelegramID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUserByTelegramIDExpectation) Then(u1 models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUserByTelegramIDResults{u1, err}
	return e.mock
}

// GetUserByTelegramID implements Repository
func (mmGetUserByTelegramID *RepositoryMock) GetUserByTelegramID(ctx context.Context, i1 int) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByTelegramID.beforeGetUserByTelegramIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByTelegramID.afterGetUserByTelegramIDCounter, 1)

	if mmGetUserByTelegramID.inspectFuncGetUserByTelegramID != nil {
		mmGetUserByTelegramID.inspectFuncGetUserByTelegramID(ctx, i1)
	}

	mm_params := &RepositoryMockGetUserByTelegramIDParams{ctx, i1}

	// Record call args
	mmGetUserByTelegramID.GetUserByTelegramIDMock.mutex.Lock()
	mmGetUserByTelegramID.GetUserByTelegramIDMock.callArgs = append(mmGetUserByTelegramID.GetUserByTelegramIDMock.callArgs, mm_params)
	mmGetUserByTelegramID.GetUserByTelegramIDMock.mutex.Unlock()

	for _, e := range mmGetUserByTelegramID.GetUserByTelegramIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.params
		mm_got := RepositoryMockGetUserByTelegramIDParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByTelegramID.t.Errorf("RepositoryMock.GetUserByTelegramID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByTelegramID.GetUserByTelegramIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByTelegramID.t.Fatal("No results are set for the RepositoryMock.GetUserByTelegramID")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetUserByTelegramID.funcGetUserByTelegramID != nil {
		return mmGetUserByTelegramID.funcGetUserByTelegramID(ctx, i1)
	}
	mmGetUserByTelegramID.t.Fatalf("Unexpected call to RepositoryMock.GetUserByTelegramID. %v %v", ctx, i1)
	return
}

// GetUserByTelegramIDAfterCounter returns a count of finished RepositoryMock.GetUserByTelegramID invocations
func (mmGetUserByTelegramID *RepositoryMock) GetUserByTelegramIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByTelegramID.afterGetUserByTelegramIDCounter)
}

// GetUserByTelegramIDBeforeCounter returns a count of RepositoryMock.GetUserByTelegramID invocations
func (mmGetUserByTelegramID *RepositoryMock) GetUserByTelegramIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByTelegramID.beforeGetUserByTelegramIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUserByTelegramID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByTelegramID *mRepositoryMockGetUserByTelegramID) Calls() []*RepositoryMockGetUserByTelegramIDParams {
	mmGetUserByTelegramID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUserByTelegramIDParams, len(mmGetUserByTelegramID.callArgs))
	copy(argCopy, mmGetUserByTelegramID.callArgs)

	mmGetUserByTelegramID.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByTelegramIDDone returns true if the count of the GetUserByTelegramID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUserByTelegramIDDone() bool {
	for _, e := range m.GetUserByTelegramIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByTelegramIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByTelegramID != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByTelegramIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUserByTelegramIDInspect() {
	for _, e := range m.GetUserByTelegramIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByTelegramID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByTelegramIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		if m.GetUserByTelegramIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetUserByTelegramID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUserByTelegramID with params: %#v", *m.GetUserByTelegramIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByTelegramID != nil && mm_atomic.LoadUint64(&m.afterGetUserByTelegramIDCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUserByTelegramID")
	}
}

type mRepositoryMockGetUsersByIDs struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetUsersByIDsExpectation
	expectations       []*RepositoryMockGetUsersByIDsExpectation

	callArgs []*RepositoryMockGetUsersByIDsParams
	mutex    sync.RWMutex
}

// RepositoryMockGetUsersByIDsExpectation specifies expectation struct of the Repository.GetUsersByIDs
type RepositoryMockGetUsersByIDsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetUsersByIDsParams
	results *RepositoryMockGetUsersByIDsResults
	Counter uint64
}

// RepositoryMockGetUsersByIDsParams contains parameters of the Repository.GetUsersByIDs
type RepositoryMockGetUsersByIDsParams struct {
	ctx context.Context
	ia1 []int64
}

// RepositoryMockGetUsersByIDsResults contains results of the Repository.GetUsersByIDs
type RepositoryMockGetUsersByIDsResults struct {
	ua1 []models.User
	err error
}

// Expect sets up expected params for Repository.GetUsersByIDs
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) Expect(ctx context.Context, ia1 []int64) *mRepositoryMockGetUsersByIDs {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("RepositoryMock.GetUsersByIDs mock is already set by Set")
	}

	if mmGetUsersByIDs.defaultExpectation == nil {
		mmGetUsersByIDs.defaultExpectation = &RepositoryMockGetUsersByIDsExpectation{}
	}

	mmGetUsersByIDs.defaultExpectation.params = &RepositoryMockGetUsersByIDsParams{ctx, ia1}
	for _, e := range mmGetUsersByIDs.expectations {
		if minimock.Equal(e.params, mmGetUsersByIDs.defaultExpectation.params) {
			mmGetUsersByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUsersByIDs.defaultExpectation.params)
		}
	}

	return mmGetUsersByIDs
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetUsersByIDs
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) Inspect(f func(ctx context.Context, ia1 []int64)) *mRepositoryMockGetUsersByIDs {
	if mmGetUsersByIDs.mock.inspectFuncGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetUsersByIDs")
	}

	mmGetUsersByIDs.mock.inspectFuncGetUsersByIDs = f

	return mmGetUsersByIDs
}

// Return sets up results that will be returned by Repository.GetUsersByIDs
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) Return(ua1 []models.User, err error) *RepositoryMock {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("RepositoryMock.GetUsersByIDs mock is already set by Set")
	}

	if mmGetUsersByIDs.defaultExpectation == nil {
		mmGetUsersByIDs.defaultExpectation = &RepositoryMockGetUsersByIDsExpectation{mock: mmGetUsersByIDs.mock}
	}
	mmGetUsersByIDs.defaultExpectation.results = &RepositoryMockGetUsersByIDsResults{ua1, err}
	return mmGetUsersByIDs.mock
}

//Set uses given function f to mock the Repository.GetUsersByIDs method
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) Set(f func(ctx context.Context, ia1 []int64) (ua1 []models.User, err error)) *RepositoryMock {
	if mmGetUsersByIDs.defaultExpectation != nil {
		mmGetUsersByIDs.mock.t.Fatalf("Default expectation is already set for the Repository.GetUsersByIDs method")
	}

	if len(mmGetUsersByIDs.expectations) > 0 {
		mmGetUsersByIDs.mock.t.Fatalf("Some expectations are already set for the Repository.GetUsersByIDs method")
	}

	mmGetUsersByIDs.mock.funcGetUsersByIDs = f
	return mmGetUsersByIDs.mock
}

// When sets expectation for the Repository.GetUsersByIDs which will trigger the result defined by the following
// Then helper
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) When(ctx context.Context, ia1 []int64) *RepositoryMockGetUsersByIDsExpectation {
	if mmGetUsersByIDs.mock.funcGetUsersByIDs != nil {
		mmGetUsersByIDs.mock.t.Fatalf("RepositoryMock.GetUsersByIDs mock is already set by Set")
	}

	expectation := &RepositoryMockGetUsersByIDsExpectation{
		mock:   mmGetUsersByIDs.mock,
		params: &RepositoryMockGetUsersByIDsParams{ctx, ia1},
	}
	mmGetUsersByIDs.expectations = append(mmGetUsersByIDs.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetUsersByIDs return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetUsersByIDsExpectation) Then(ua1 []models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockGetUsersByIDsResults{ua1, err}
	return e.mock
}

// GetUsersByIDs implements Repository
func (mmGetUsersByIDs *RepositoryMock) GetUsersByIDs(ctx context.Context, ia1 []int64) (ua1 []models.User, err error) {
	mm_atomic.AddUint64(&mmGetUsersByIDs.beforeGetUsersByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUsersByIDs.afterGetUsersByIDsCounter, 1)

	if mmGetUsersByIDs.inspectFuncGetUsersByIDs != nil {
		mmGetUsersByIDs.inspectFuncGetUsersByIDs(ctx, ia1)
	}

	mm_params := &RepositoryMockGetUsersByIDsParams{ctx, ia1}

	// Record call args
	mmGetUsersByIDs.GetUsersByIDsMock.mutex.Lock()
	mmGetUsersByIDs.GetUsersByIDsMock.callArgs = append(mmGetUsersByIDs.GetUsersByIDsMock.callArgs, mm_params)
	mmGetUsersByIDs.GetUsersByIDsMock.mutex.Unlock()

	for _, e := range mmGetUsersByIDs.GetUsersByIDsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.params
		mm_got := RepositoryMockGetUsersByIDsParams{ctx, ia1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUsersByIDs.t.Errorf("RepositoryMock.GetUsersByIDs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUsersByIDs.GetUsersByIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUsersByIDs.t.Fatal("No results are set for the RepositoryMock.GetUsersByIDs")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetUsersByIDs.funcGetUsersByIDs != nil {
		return mmGetUsersByIDs.funcGetUsersByIDs(ctx, ia1)
	}
	mmGetUsersByIDs.t.Fatalf("Unexpected call to RepositoryMock.GetUsersByIDs. %v %v", ctx, ia1)
	return
}

// GetUsersByIDsAfterCounter returns a count of finished RepositoryMock.GetUsersByIDs invocations
func (mmGetUsersByIDs *RepositoryMock) GetUsersByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByIDs.afterGetUsersByIDsCounter)
}

// GetUsersByIDsBeforeCounter returns a count of RepositoryMock.GetUsersByIDs invocations
func (mmGetUsersByIDs *RepositoryMock) GetUsersByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUsersByIDs.beforeGetUsersByIDsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetUsersByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUsersByIDs *mRepositoryMockGetUsersByIDs) Calls() []*RepositoryMockGetUsersByIDsParams {
	mmGetUsersByIDs.mutex.RLock()

	argCopy := make([]*RepositoryMockGetUsersByIDsParams, len(mmGetUsersByIDs.callArgs))
	copy(argCopy, mmGetUsersByIDs.callArgs)

	mmGetUsersByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetUsersByIDsDone returns true if the count of the GetUsersByIDs invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetUsersByIDsDone() bool {
	for _, e := range m.GetUsersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByIDs != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUsersByIDsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetUsersByIDsInspect() {
	for _, e := range m.GetUsersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetUsersByIDs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUsersByIDsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		if m.GetUsersByIDsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetUsersByIDs")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetUsersByIDs with params: %#v", *m.GetUsersByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUsersByIDs != nil && mm_atomic.LoadUint64(&m.afterGetUsersByIDsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetUsersByIDs")
	}
}

type mRepositoryMockReadSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadSubscriberExpectation
	expectations       []*RepositoryMockReadSubscriberExpectation

	callArgs []*RepositoryMockReadSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockReadSubscriberExpectation specifies expectation struct of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadSubscriberParams
	results *RepositoryMockReadSubscriberResults
	Counter uint64
}

// RepositoryMockReadSubscriberParams contains parameters of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadSubscriberResults contains results of the Repository.ReadSubscriber
type RepositoryMockReadSubscriberResults struct {
	s1  models.Subscriber
	err error
}

// Expect sets up expected params for Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Expect(ctx context.Context, i1 int) *mRepositoryMockReadSubscriber {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &RepositoryMockReadSubscriberExpectation{}
	}

	mmReadSubscriber.defaultExpectation.params = &RepositoryMockReadSubscriberParams{ctx, i1}
	for _, e := range mmReadSubscriber.expectations {
		if minimock.Equal(e.params, mmReadSubscriber.defaultExpectation.params) {
			mmReadSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscriber.defaultExpectation.params)
		}
	}

	return mmReadSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadSubscriber {
	if mmReadSubscriber.mock.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadSubscriber")
	}

	mmReadSubscriber.mock.inspectFuncReadSubscriber = f

	return mmReadSubscriber
}

// Return sets up results that will be returned by Repository.ReadSubscriber
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Return(s1 models.Subscriber, err error) *RepositoryMock {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	if mmReadSubscriber.defaultExpectation == nil {
		mmReadSubscriber.defaultExpectation = &RepositoryMockReadSubscriberExpectation{mock: mmReadSubscriber.mock}
	}
	mmReadSubscriber.defaultExpectation.results = &RepositoryMockReadSubscriberResults{s1, err}
	return mmReadSubscriber.mock
}

//Set uses given function f to mock the Repository.ReadSubscriber method
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Set(f func(ctx context.Context, i1 int) (s1 models.Subscriber, err error)) *RepositoryMock {
	if mmReadSubscriber.defaultExpectation != nil {
		mmReadSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.ReadSubscriber method")
	}

	if len(mmReadSubscriber.expectations) > 0 {
		mmReadSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.ReadSubscriber method")
	}

	mmReadSubscriber.mock.funcReadSubscriber = f
	return mmReadSubscriber.mock
}

// When sets expectation for the Repository.ReadSubscriber which will trigger the result defined by the following
// Then helper
func (mmReadSubscriber *mRepositoryMockReadSubscriber) When(ctx context.Context, i1 int) *RepositoryMockReadSubscriberExpectation {
	if mmReadSubscriber.mock.funcReadSubscriber != nil {
		mmReadSubscriber.mock.t.Fatalf("RepositoryMock.ReadSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockReadSubscriberExpectation{
		mock:   mmReadSubscriber.mock,
		params: &RepositoryMockReadSubscriberParams{ctx, i1},
	}
	mmReadSubscriber.expectations = append(mmReadSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadSubscriberExpectation) Then(s1 models.Subscriber, err error) *RepositoryMock {
	e.results = &RepositoryMockReadSubscriberResults{s1, err}
	return e.mock
}

// ReadSubscriber implements Repository
func (mmReadSubscriber *RepositoryMock) ReadSubscriber(ctx context.Context, i1 int) (s1 models.Subscriber, err error) {
	mm_atomic.AddUint64(&mmReadSubscriber.beforeReadSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscriber.afterReadSubscriberCounter, 1)

	if mmReadSubscriber.inspectFuncReadSubscriber != nil {
		mmReadSubscriber.inspectFuncReadSubscriber(ctx, i1)
	}

	mm_params := &RepositoryMockReadSubscriberParams{ctx, i1}

	// Record call args
	mmReadSubscriber.ReadSubscriberMock.mutex.Lock()
	mmReadSubscriber.ReadSubscriberMock.callArgs = append(mmReadSubscriber.ReadSubscriberMock.callArgs, mm_params)
	mmReadSubscriber.ReadSubscriberMock.mutex.Unlock()

	for _, e := range mmReadSubscriber.ReadSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSubscriber.ReadSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscriber.ReadSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockReadSubscriberParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscriber.t.Errorf("RepositoryMock.ReadSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscriber.ReadSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscriber.t.Fatal("No results are set for the RepositoryMock.ReadSubscriber")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmReadSubscriber.funcReadSubscriber != nil {
		return mmReadSubscriber.funcReadSubscriber(ctx, i1)
	}
	mmReadSubscriber.t.Fatalf("Unexpected call to RepositoryMock.ReadSubscriber. %v %v", ctx, i1)
	return
}

// ReadSubscriberAfterCounter returns a count of finished RepositoryMock.ReadSubscriber invocations
func (mmReadSubscriber *RepositoryMock) ReadSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.afterReadSubscriberCounter)
}

// ReadSubscriberBeforeCounter returns a count of RepositoryMock.ReadSubscriber invocations
func (mmReadSubscriber *RepositoryMock) ReadSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscriber.beforeReadSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscriber *mRepositoryMockReadSubscriber) Calls() []*RepositoryMockReadSubscriberParams {
	mmReadSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockReadSubscriberParams, len(mmReadSubscriber.callArgs))
	copy(argCopy, mmReadSubscriber.callArgs)

	mmReadSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriberDone returns true if the count of the ReadSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadSubscriberDone() bool {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadSubscriberInspect() {
	for _, e := range m.ReadSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		if m.ReadSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscriber with params: %#v", *m.ReadSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscriber != nil && mm_atomic.LoadUint64(&m.afterReadSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadSubscriber")
	}
}

type mRepositoryMockReadSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadSubscriptionExpectation
	expectations       []*RepositoryMockReadSubscriptionExpectation

	callArgs []*RepositoryMockReadSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockReadSubscriptionExpectation specifies expectation struct of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadSubscriptionParams
	results *RepositoryMockReadSubscriptionResults
	Counter uint64
}

// RepositoryMockReadSubscriptionParams contains parameters of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadSubscriptionResults contains results of the Repository.ReadSubscription
type RepositoryMockReadSubscriptionResults struct {
	s1  models.Subscription
	err error
}

// Expect sets up expected params for Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Expect(ctx context.Context, i1 int) *mRepositoryMockReadSubscription {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &RepositoryMockReadSubscriptionExpectation{}
	}

	mmReadSubscription.defaultExpectation.params = &RepositoryMockReadSubscriptionParams{ctx, i1}
	for _, e := range mmReadSubscription.expectations {
		if minimock.Equal(e.params, mmReadSubscription.defaultExpectation.params) {
			mmReadSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadSubscription.defaultExpectation.params)
		}
	}

	return mmReadSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadSubscription {
	if mmReadSubscription.mock.inspectFuncReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadSubscription")
	}

	mmReadSubscription.mock.inspectFuncReadSubscription = f

	return mmReadSubscription
}

// Return sets up results that will be returned by Repository.ReadSubscription
func (mmReadSubscription *mRepositoryMockReadSubscription) Return(s1 models.Subscription, err error) *RepositoryMock {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	if mmReadSubscription.defaultExpectation == nil {
		mmReadSubscription.defaultExpectation = &RepositoryMockReadSubscriptionExpectation{mock: mmReadSubscription.mock}
	}
	mmReadSubscription.defaultExpectation.results = &RepositoryMockReadSubscriptionResults{s1, err}
	return mmReadSubscription.mock
}

//Set uses given function f to mock the Repository.ReadSubscription method
func (mmReadSubscription *mRepositoryMockReadSubscription) Set(f func(ctx context.Context, i1 int) (s1 models.Subscription, err error)) *RepositoryMock {
	if mmReadSubscription.defaultExpectation != nil {
		mmReadSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.ReadSubscription method")
	}

	if len(mmReadSubscription.expectations) > 0 {
		mmReadSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.ReadSubscription method")
	}

	mmReadSubscription.mock.funcReadSubscription = f
	return mmReadSubscription.mock
}

// When sets expectation for the Repository.ReadSubscription which will trigger the result defined by the following
// Then helper
func (mmReadSubscription *mRepositoryMockReadSubscription) When(ctx context.Context, i1 int) *RepositoryMockReadSubscriptionExpectation {
	if mmReadSubscription.mock.funcReadSubscription != nil {
		mmReadSubscription.mock.t.Fatalf("RepositoryMock.ReadSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockReadSubscriptionExpectation{
		mock:   mmReadSubscription.mock,
		params: &RepositoryMockReadSubscriptionParams{ctx, i1},
	}
	mmReadSubscription.expectations = append(mmReadSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadSubscriptionExpectation) Then(s1 models.Subscription, err error) *RepositoryMock {
	e.results = &RepositoryMockReadSubscriptionResults{s1, err}
	return e.mock
}

// ReadSubscription implements Repository
func (mmReadSubscription *RepositoryMock) ReadSubscription(ctx context.Context, i1 int) (s1 models.Subscription, err error) {
	mm_atomic.AddUint64(&mmReadSubscription.beforeReadSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmReadSubscription.afterReadSubscriptionCounter, 1)

	if mmReadSubscription.inspectFuncReadSubscription != nil {
		mmReadSubscription.inspectFuncReadSubscription(ctx, i1)
	}

	mm_params := &RepositoryMockReadSubscriptionParams{ctx, i1}

	// Record call args
	mmReadSubscription.ReadSubscriptionMock.mutex.Lock()
	mmReadSubscription.ReadSubscriptionMock.callArgs = append(mmReadSubscription.ReadSubscriptionMock.callArgs, mm_params)
	mmReadSubscription.ReadSubscriptionMock.mutex.Unlock()

	for _, e := range mmReadSubscription.ReadSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmReadSubscription.ReadSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadSubscription.ReadSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockReadSubscriptionParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadSubscription.t.Errorf("RepositoryMock.ReadSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadSubscription.ReadSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmReadSubscription.t.Fatal("No results are set for the RepositoryMock.ReadSubscription")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmReadSubscription.funcReadSubscription != nil {
		return mmReadSubscription.funcReadSubscription(ctx, i1)
	}
	mmReadSubscription.t.Fatalf("Unexpected call to RepositoryMock.ReadSubscription. %v %v", ctx, i1)
	return
}

// ReadSubscriptionAfterCounter returns a count of finished RepositoryMock.ReadSubscription invocations
func (mmReadSubscription *RepositoryMock) ReadSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.afterReadSubscriptionCounter)
}

// ReadSubscriptionBeforeCounter returns a count of RepositoryMock.ReadSubscription invocations
func (mmReadSubscription *RepositoryMock) ReadSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadSubscription.beforeReadSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadSubscription *mRepositoryMockReadSubscription) Calls() []*RepositoryMockReadSubscriptionParams {
	mmReadSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockReadSubscriptionParams, len(mmReadSubscription.callArgs))
	copy(argCopy, mmReadSubscription.callArgs)

	mmReadSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockReadSubscriptionDone returns true if the count of the ReadSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadSubscriptionDone() bool {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadSubscriptionInspect() {
	for _, e := range m.ReadSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		if m.ReadSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadSubscription with params: %#v", *m.ReadSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadSubscription != nil && mm_atomic.LoadUint64(&m.afterReadSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadSubscription")
	}
}

type mRepositoryMockReadUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReadUserExpectation
	expectations       []*RepositoryMockReadUserExpectation

	callArgs []*RepositoryMockReadUserParams
	mutex    sync.RWMutex
}

// RepositoryMockReadUserExpectation specifies expectation struct of the Repository.ReadUser
type RepositoryMockReadUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReadUserParams
	results *RepositoryMockReadUserResults
	Counter uint64
}

// RepositoryMockReadUserParams contains parameters of the Repository.ReadUser
type RepositoryMockReadUserParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockReadUserResults contains results of the Repository.ReadUser
type RepositoryMockReadUserResults struct {
	u1  models.User
	err error
}

// Expect sets up expected params for Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Expect(ctx context.Context, i1 int) *mRepositoryMockReadUser {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &RepositoryMockReadUserExpectation{}
	}

	mmReadUser.defaultExpectation.params = &RepositoryMockReadUserParams{ctx, i1}
	for _, e := range mmReadUser.expectations {
		if minimock.Equal(e.params, mmReadUser.defaultExpectation.params) {
			mmReadUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReadUser.defaultExpectation.params)
		}
	}

	return mmReadUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockReadUser {
	if mmReadUser.mock.inspectFuncReadUser != nil {
		mmReadUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReadUser")
	}

	mmReadUser.mock.inspectFuncReadUser = f

	return mmReadUser
}

// Return sets up results that will be returned by Repository.ReadUser
func (mmReadUser *mRepositoryMockReadUser) Return(u1 models.User, err error) *RepositoryMock {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	if mmReadUser.defaultExpectation == nil {
		mmReadUser.defaultExpectation = &RepositoryMockReadUserExpectation{mock: mmReadUser.mock}
	}
	mmReadUser.defaultExpectation.results = &RepositoryMockReadUserResults{u1, err}
	return mmReadUser.mock
}

//Set uses given function f to mock the Repository.ReadUser method
func (mmReadUser *mRepositoryMockReadUser) Set(f func(ctx context.Context, i1 int) (u1 models.User, err error)) *RepositoryMock {
	if mmReadUser.defaultExpectation != nil {
		mmReadUser.mock.t.Fatalf("Default expectation is already set for the Repository.ReadUser method")
	}

	if len(mmReadUser.expectations) > 0 {
		mmReadUser.mock.t.Fatalf("Some expectations are already set for the Repository.ReadUser method")
	}

	mmReadUser.mock.funcReadUser = f
	return mmReadUser.mock
}

// When sets expectation for the Repository.ReadUser which will trigger the result defined by the following
// Then helper
func (mmReadUser *mRepositoryMockReadUser) When(ctx context.Context, i1 int) *RepositoryMockReadUserExpectation {
	if mmReadUser.mock.funcReadUser != nil {
		mmReadUser.mock.t.Fatalf("RepositoryMock.ReadUser mock is already set by Set")
	}

	expectation := &RepositoryMockReadUserExpectation{
		mock:   mmReadUser.mock,
		params: &RepositoryMockReadUserParams{ctx, i1},
	}
	mmReadUser.expectations = append(mmReadUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReadUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReadUserExpectation) Then(u1 models.User, err error) *RepositoryMock {
	e.results = &RepositoryMockReadUserResults{u1, err}
	return e.mock
}

// ReadUser implements Repository
func (mmReadUser *RepositoryMock) ReadUser(ctx context.Context, i1 int) (u1 models.User, err error) {
	mm_atomic.AddUint64(&mmReadUser.beforeReadUserCounter, 1)
	defer mm_atomic.AddUint64(&mmReadUser.afterReadUserCounter, 1)

	if mmReadUser.inspectFuncReadUser != nil {
		mmReadUser.inspectFuncReadUser(ctx, i1)
	}

	mm_params := &RepositoryMockReadUserParams{ctx, i1}

	// Record call args
	mmReadUser.ReadUserMock.mutex.Lock()
	mmReadUser.ReadUserMock.callArgs = append(mmReadUser.ReadUserMock.callArgs, mm_params)
	mmReadUser.ReadUserMock.mutex.Unlock()

	for _, e := range mmReadUser.ReadUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmReadUser.ReadUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReadUser.ReadUserMock.defaultExpectation.Counter, 1)
		mm_want := mmReadUser.ReadUserMock.defaultExpectation.params
		mm_got := RepositoryMockReadUserParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReadUser.t.Errorf("RepositoryMock.ReadUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReadUser.ReadUserMock.defaultExpectation.results
		if mm_results == nil {
			mmReadUser.t.Fatal("No results are set for the RepositoryMock.ReadUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmReadUser.funcReadUser != nil {
		return mmReadUser.funcReadUser(ctx, i1)
	}
	mmReadUser.t.Fatalf("Unexpected call to RepositoryMock.ReadUser. %v %v", ctx, i1)
	return
}

// ReadUserAfterCounter returns a count of finished RepositoryMock.ReadUser invocations
func (mmReadUser *RepositoryMock) ReadUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.afterReadUserCounter)
}

// ReadUserBeforeCounter returns a count of RepositoryMock.ReadUser invocations
func (mmReadUser *RepositoryMock) ReadUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReadUser.beforeReadUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReadUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReadUser *mRepositoryMockReadUser) Calls() []*RepositoryMockReadUserParams {
	mmReadUser.mutex.RLock()

	argCopy := make([]*RepositoryMockReadUserParams, len(mmReadUser.callArgs))
	copy(argCopy, mmReadUser.callArgs)

	mmReadUser.mutex.RUnlock()

	return argCopy
}

// MinimockReadUserDone returns true if the count of the ReadUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReadUserDone() bool {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockReadUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReadUserInspect() {
	for _, e := range m.ReadUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReadUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReadUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		if m.ReadUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReadUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReadUser with params: %#v", *m.ReadUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReadUser != nil && mm_atomic.LoadUint64(&m.afterReadUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReadUser")
	}
}

type mRepositoryMockUpdateSubscriber struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSubscriberExpectation
	expectations       []*RepositoryMockUpdateSubscriberExpectation

	callArgs []*RepositoryMockUpdateSubscriberParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateSubscriberExpectation specifies expectation struct of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateSubscriberParams
	results *RepositoryMockUpdateSubscriberResults
	Counter uint64
}

// RepositoryMockUpdateSubscriberParams contains parameters of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberParams struct {
	ctx context.Context
	s1  models.Subscriber
}

// RepositoryMockUpdateSubscriberResults contains results of the Repository.UpdateSubscriber
type RepositoryMockUpdateSubscriberResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Expect(ctx context.Context, s1 models.Subscriber) *mRepositoryMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &RepositoryMockUpdateSubscriberExpectation{}
	}

	mmUpdateSubscriber.defaultExpectation.params = &RepositoryMockUpdateSubscriberParams{ctx, s1}
	for _, e := range mmUpdateSubscriber.expectations {
		if minimock.Equal(e.params, mmUpdateSubscriber.defaultExpectation.params) {
			mmUpdateSubscriber.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscriber.defaultExpectation.params)
		}
	}

	return mmUpdateSubscriber
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Inspect(f func(ctx context.Context, s1 models.Subscriber)) *mRepositoryMockUpdateSubscriber {
	if mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSubscriber")
	}

	mmUpdateSubscriber.mock.inspectFuncUpdateSubscriber = f

	return mmUpdateSubscriber
}

// Return sets up results that will be returned by Repository.UpdateSubscriber
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Return(err error) *RepositoryMock {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	if mmUpdateSubscriber.defaultExpectation == nil {
		mmUpdateSubscriber.defaultExpectation = &RepositoryMockUpdateSubscriberExpectation{mock: mmUpdateSubscriber.mock}
	}
	mmUpdateSubscriber.defaultExpectation.results = &RepositoryMockUpdateSubscriberResults{err}
	return mmUpdateSubscriber.mock
}

//Set uses given function f to mock the Repository.UpdateSubscriber method
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Set(f func(ctx context.Context, s1 models.Subscriber) (err error)) *RepositoryMock {
	if mmUpdateSubscriber.defaultExpectation != nil {
		mmUpdateSubscriber.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSubscriber method")
	}

	if len(mmUpdateSubscriber.expectations) > 0 {
		mmUpdateSubscriber.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSubscriber method")
	}

	mmUpdateSubscriber.mock.funcUpdateSubscriber = f
	return mmUpdateSubscriber.mock
}

// When sets expectation for the Repository.UpdateSubscriber which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) When(ctx context.Context, s1 models.Subscriber) *RepositoryMockUpdateSubscriberExpectation {
	if mmUpdateSubscriber.mock.funcUpdateSubscriber != nil {
		mmUpdateSubscriber.mock.t.Fatalf("RepositoryMock.UpdateSubscriber mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSubscriberExpectation{
		mock:   mmUpdateSubscriber.mock,
		params: &RepositoryMockUpdateSubscriberParams{ctx, s1},
	}
	mmUpdateSubscriber.expectations = append(mmUpdateSubscriber.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSubscriber return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSubscriberExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSubscriberResults{err}
	return e.mock
}

// UpdateSubscriber implements Repository
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriber(ctx context.Context, s1 models.Subscriber) (err error) {
	mm_atomic.AddUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter, 1)

	if mmUpdateSubscriber.inspectFuncUpdateSubscriber != nil {
		mmUpdateSubscriber.inspectFuncUpdateSubscriber(ctx, s1)
	}

	mm_params := &RepositoryMockUpdateSubscriberParams{ctx, s1}

	// Record call args
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Lock()
	mmUpdateSubscriber.UpdateSubscriberMock.callArgs = append(mmUpdateSubscriber.UpdateSubscriberMock.callArgs, mm_params)
	mmUpdateSubscriber.UpdateSubscriberMock.mutex.Unlock()

	for _, e := range mmUpdateSubscriber.UpdateSubscriberMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateSubscriberParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscriber.t.Errorf("RepositoryMock.UpdateSubscriber got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscriber.UpdateSubscriberMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscriber.t.Fatal("No results are set for the RepositoryMock.UpdateSubscriber")
		}
		return (*mm_results).err
	}
	if mmUpdateSubscriber.funcUpdateSubscriber != nil {
		return mmUpdateSubscriber.funcUpdateSubscriber(ctx, s1)
	}
	mmUpdateSubscriber.t.Fatalf("Unexpected call to RepositoryMock.UpdateSubscriber. %v %v", ctx, s1)
	return
}

// UpdateSubscriberAfterCounter returns a count of finished RepositoryMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriberAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.afterUpdateSubscriberCounter)
}

// UpdateSubscriberBeforeCounter returns a count of RepositoryMock.UpdateSubscriber invocations
func (mmUpdateSubscriber *RepositoryMock) UpdateSubscriberBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscriber.beforeUpdateSubscriberCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSubscriber.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscriber *mRepositoryMockUpdateSubscriber) Calls() []*RepositoryMockUpdateSubscriberParams {
	mmUpdateSubscriber.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSubscriberParams, len(mmUpdateSubscriber.callArgs))
	copy(argCopy, mmUpdateSubscriber.callArgs)

	mmUpdateSubscriber.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriberDone returns true if the count of the UpdateSubscriber invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSubscriberDone() bool {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriberInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSubscriberInspect() {
	for _, e := range m.UpdateSubscriberMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscriber with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriberMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		if m.UpdateSubscriberMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateSubscriber")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscriber with params: %#v", *m.UpdateSubscriberMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscriber != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriberCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateSubscriber")
	}
}

type mRepositoryMockUpdateSubscription struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateSubscriptionExpectation
	expectations       []*RepositoryMockUpdateSubscriptionExpectation

	callArgs []*RepositoryMockUpdateSubscriptionParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateSubscriptionExpectation specifies expectation struct of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateSubscriptionParams
	results *RepositoryMockUpdateSubscriptionResults
	Counter uint64
}

// RepositoryMockUpdateSubscriptionParams contains parameters of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionParams struct {
	ctx context.Context
	s1  models.Subscription
}

// RepositoryMockUpdateSubscriptionResults contains results of the Repository.UpdateSubscription
type RepositoryMockUpdateSubscriptionResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Expect(ctx context.Context, s1 models.Subscription) *mRepositoryMockUpdateSubscription {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &RepositoryMockUpdateSubscriptionExpectation{}
	}

	mmUpdateSubscription.defaultExpectation.params = &RepositoryMockUpdateSubscriptionParams{ctx, s1}
	for _, e := range mmUpdateSubscription.expectations {
		if minimock.Equal(e.params, mmUpdateSubscription.defaultExpectation.params) {
			mmUpdateSubscription.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateSubscription.defaultExpectation.params)
		}
	}

	return mmUpdateSubscription
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Inspect(f func(ctx context.Context, s1 models.Subscription)) *mRepositoryMockUpdateSubscription {
	if mmUpdateSubscription.mock.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateSubscription")
	}

	mmUpdateSubscription.mock.inspectFuncUpdateSubscription = f

	return mmUpdateSubscription
}

// Return sets up results that will be returned by Repository.UpdateSubscription
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Return(err error) *RepositoryMock {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	if mmUpdateSubscription.defaultExpectation == nil {
		mmUpdateSubscription.defaultExpectation = &RepositoryMockUpdateSubscriptionExpectation{mock: mmUpdateSubscription.mock}
	}
	mmUpdateSubscription.defaultExpectation.results = &RepositoryMockUpdateSubscriptionResults{err}
	return mmUpdateSubscription.mock
}

//Set uses given function f to mock the Repository.UpdateSubscription method
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Set(f func(ctx context.Context, s1 models.Subscription) (err error)) *RepositoryMock {
	if mmUpdateSubscription.defaultExpectation != nil {
		mmUpdateSubscription.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateSubscription method")
	}

	if len(mmUpdateSubscription.expectations) > 0 {
		mmUpdateSubscription.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateSubscription method")
	}

	mmUpdateSubscription.mock.funcUpdateSubscription = f
	return mmUpdateSubscription.mock
}

// When sets expectation for the Repository.UpdateSubscription which will trigger the result defined by the following
// Then helper
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) When(ctx context.Context, s1 models.Subscription) *RepositoryMockUpdateSubscriptionExpectation {
	if mmUpdateSubscription.mock.funcUpdateSubscription != nil {
		mmUpdateSubscription.mock.t.Fatalf("RepositoryMock.UpdateSubscription mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateSubscriptionExpectation{
		mock:   mmUpdateSubscription.mock,
		params: &RepositoryMockUpdateSubscriptionParams{ctx, s1},
	}
	mmUpdateSubscription.expectations = append(mmUpdateSubscription.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateSubscription return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateSubscriptionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateSubscriptionResults{err}
	return e.mock
}

// UpdateSubscription implements Repository
func (mmUpdateSubscription *RepositoryMock) UpdateSubscription(ctx context.Context, s1 models.Subscription) (err error) {
	mm_atomic.AddUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter, 1)

	if mmUpdateSubscription.inspectFuncUpdateSubscription != nil {
		mmUpdateSubscription.inspectFuncUpdateSubscription(ctx, s1)
	}

	mm_params := &RepositoryMockUpdateSubscriptionParams{ctx, s1}

	// Record call args
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Lock()
	mmUpdateSubscription.UpdateSubscriptionMock.callArgs = append(mmUpdateSubscription.UpdateSubscriptionMock.callArgs, mm_params)
	mmUpdateSubscription.UpdateSubscriptionMock.mutex.Unlock()

	for _, e := range mmUpdateSubscription.UpdateSubscriptionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateSubscriptionParams{ctx, s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateSubscription.t.Errorf("RepositoryMock.UpdateSubscription got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateSubscription.UpdateSubscriptionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateSubscription.t.Fatal("No results are set for the RepositoryMock.UpdateSubscription")
		}
		return (*mm_results).err
	}
	if mmUpdateSubscription.funcUpdateSubscription != nil {
		return mmUpdateSubscription.funcUpdateSubscription(ctx, s1)
	}
	mmUpdateSubscription.t.Fatalf("Unexpected call to RepositoryMock.UpdateSubscription. %v %v", ctx, s1)
	return
}

// UpdateSubscriptionAfterCounter returns a count of finished RepositoryMock.UpdateSubscription invocations
func (mmUpdateSubscription *RepositoryMock) UpdateSubscriptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.afterUpdateSubscriptionCounter)
}

// UpdateSubscriptionBeforeCounter returns a count of RepositoryMock.UpdateSubscription invocations
func (mmUpdateSubscription *RepositoryMock) UpdateSubscriptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateSubscription.beforeUpdateSubscriptionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateSubscription.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateSubscription *mRepositoryMockUpdateSubscription) Calls() []*RepositoryMockUpdateSubscriptionParams {
	mmUpdateSubscription.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateSubscriptionParams, len(mmUpdateSubscription.callArgs))
	copy(argCopy, mmUpdateSubscription.callArgs)

	mmUpdateSubscription.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateSubscriptionDone returns true if the count of the UpdateSubscription invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateSubscriptionDone() bool {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateSubscriptionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateSubscriptionInspect() {
	for _, e := range m.UpdateSubscriptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscription with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateSubscriptionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		if m.UpdateSubscriptionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateSubscription")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateSubscription with params: %#v", *m.UpdateSubscriptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateSubscription != nil && mm_atomic.LoadUint64(&m.afterUpdateSubscriptionCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateSubscription")
	}
}

type mRepositoryMockUpdateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateUserExpectation
	expectations       []*RepositoryMockUpdateUserExpectation

	callArgs []*RepositoryMockUpdateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockUpdateUserExpectation specifies expectation struct of the Repository.UpdateUser
type RepositoryMockUpdateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockUpdateUserParams
	results *RepositoryMockUpdateUserResults
	Counter uint64
}

// RepositoryMockUpdateUserParams contains parameters of the Repository.UpdateUser
type RepositoryMockUpdateUserParams struct {
	ctx context.Context
	u1  models.User
}

// RepositoryMockUpdateUserResults contains results of the Repository.UpdateUser
type RepositoryMockUpdateUserResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Expect(ctx context.Context, u1 models.User) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{}
	}

	mmUpdateUser.defaultExpectation.params = &RepositoryMockUpdateUserParams{ctx, u1}
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Inspect(f func(ctx context.Context, u1 models.User)) *mRepositoryMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by Repository.UpdateUser
func (mmUpdateUser *mRepositoryMockUpdateUser) Return(err error) *RepositoryMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &RepositoryMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &RepositoryMockUpdateUserResults{err}
	return mmUpdateUser.mock
}

//Set uses given function f to mock the Repository.UpdateUser method
func (mmUpdateUser *mRepositoryMockUpdateUser) Set(f func(ctx context.Context, u1 models.User) (err error)) *RepositoryMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	return mmUpdateUser.mock
}

// When sets expectation for the Repository.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mRepositoryMockUpdateUser) When(ctx context.Context, u1 models.User) *RepositoryMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("RepositoryMock.UpdateUser mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateUserExpectation{
		mock:   mmUpdateUser.mock,
		params: &RepositoryMockUpdateUserParams{ctx, u1},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateUserResults{err}
	return e.mock
}

// UpdateUser implements Repository
func (mmUpdateUser *RepositoryMock) UpdateUser(ctx context.Context, u1 models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, u1)
	}

	mm_params := &RepositoryMockUpdateUserParams{ctx, u1}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_got := RepositoryMockUpdateUserParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("RepositoryMock.UpdateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the RepositoryMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, u1)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to RepositoryMock.UpdateUser. %v %v", ctx, u1)
	return
}

// UpdateUserAfterCounter returns a count of finished RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of RepositoryMock.UpdateUser invocations
func (mmUpdateUser *RepositoryMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mRepositoryMockUpdateUser) Calls() []*RepositoryMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateUserDone() bool {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateUser with params: %#v", *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && mm_atomic.LoadUint64(&m.afterUpdateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSubscriberInspect()

		m.MinimockCreateSubscriptionInspect()

		m.MinimockCreateUserInspect()

		m.MinimockDeleteSubscriberInspect()

		m.MinimockDeleteSubscriptionInspect()

		m.MinimockDeleteUserInspect()

		m.MinimockGetSubscribersForSubscriptionInspect()

		m.MinimockGetSubscriptionsForUserInspect()

		m.MinimockGetUserByTelegramIDInspect()

		m.MinimockGetUsersByIDsInspect()

		m.MinimockReadSubscriberInspect()

		m.MinimockReadSubscriptionInspect()

		m.MinimockReadUserInspect()

		m.MinimockUpdateSubscriberInspect()

		m.MinimockUpdateSubscriptionInspect()

		m.MinimockUpdateUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSubscriberDone() &&
		m.MinimockCreateSubscriptionDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteSubscriberDone() &&
		m.MinimockDeleteSubscriptionDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetSubscribersForSubscriptionDone() &&
		m.MinimockGetSubscriptionsForUserDone() &&
		m.MinimockGetUserByTelegramIDDone() &&
		m.MinimockGetUsersByIDsDone() &&
		m.MinimockReadSubscriberDone() &&
		m.MinimockReadSubscriptionDone() &&
		m.MinimockReadUserDone() &&
		m.MinimockUpdateSubscriberDone() &&
		m.MinimockUpdateSubscriptionDone() &&
		m.MinimockUpdateUserDone()
}
